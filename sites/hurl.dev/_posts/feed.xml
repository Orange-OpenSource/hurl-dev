<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom" >
    <title>Hurl Blog</title>
    <link href="https://hurl.dev/blog/feed.xml" rel="self" type="application/atom+xml" />
    <link href="https://hurl.dev/blog" rel="alternate" type="text/html" />
    <updated>2024-04-24T00:00:00+02:00</updated>
    <id>https://hurl.dev/blog/feed.xml</id>
    <entry>
        <title>Announcing Hurl 4.3.0</title>
        <link href="https://hurl.dev/blog/2024/04/24/announcing-hurl-4.3.0.html" rel="alternate" type="text/html" title="Announcing Hurl 4.3.0"/>
        <published>2024-04-24T00:00:00+02:00</published>
        <updated>2024-04-24T00:00:00+02:00</updated>
        <id>https://hurl.dev/blog/2024/04/24/announcing-hurl-4.3.0.html</id>
        <content type="html"><![CDATA[<h1>Announcing Hurl 4.3.0</h1>
<div class="blog-post-date">Apr. 24, 2024</div>

<p>The Hurl team is thrilled to announce <a href="https://github.com/Orange-OpenSource/hurl/releases/tag/4.3.0">Hurl 4.3.0</a> <picture><source srcset="https://hurl.dev/assets/img/emoji-surfer.avif" type="image/avif"><source srcset="https://hurl.dev/assets/img/emoji-surfer.webp" type="image/webp"><source srcset="https://hurl.dev/assets/img/emoji-surfer.png" type="image/png"><img class="emoji" src="https://hurl.dev/assets/img/emoji-surfer.png" width="20" height="20" alt="Surfer"></picture> !</p>
<p><a href="https://hurl.dev">Hurl</a> is a command line tool powered by <a href="https://curl.se">curl</a>, that runs HTTP requests defined in a simple plain text format:</p>
<pre><code class="language-hurl">GET https://example.org/api/tests/4567
HTTP 200
[Asserts]
header "x-foo" contains "bar"
certificate "Expire-Date" daysAfterNow &gt; 15
jsonpath "$.status" == "RUNNING"    # Check the status code
jsonpath "$.tests" count == 25      # Check the number of items
jsonpath "$.id" matches /\d{4}/     # Check the format of the id
</code></pre>
<h2>What’s New in This Release</h2>
<ul>
<li><a href="#quality-of-life-improvements">Quality of Life Improvements</a></li>
<li><a href="#shell-completion">Shell Completion</a></li>
<li><a href="#one-more-thing">One More Thing...</a></li>
<li><a href="#others">Others</a></li>
</ul>
<h2>Quality of Life Improvements</h2>
<p>Hurl 4.3.0 is about bringing various <strong>quality of life improvements</strong>. Nothing fancy, but Hurl keeps iterating,
improving and increasing usefulness on each new release.  </p>
<h3>Error display</h3>
<p>Errors display have been slightly improved, with request line displayed to give context without having to look in
the Hurl source file.</p>
<p>Before 4.3.0:</p>
<pre><code class="language-shell">error: Undefined variable
--&gt; tests_ok/post_file.hurl:6:8
   |
 6 | file,{{filename}};
   |        ^^^^^^^^ you must set the variable filename
   |
</code></pre>
<p>With 4.3.0:</p>
<pre><code class="language-shell">error: Undefined variable
--&gt; tests_ok/post_file.hurl:6:8
   |
   | POST http://localhost:8000/post-file
   | ...
 6 | file,{{filename}};
   |        ^^^^^^^^ you must set the variable filename
   |
</code></pre>
<h3>&ndash;netrc, &ndash;netrc-file, &ndash;netrc-optional</h3>
<p>Like its HTTP engine <a href="https://curl.se">curl</a>, Hurl supports now the classic <code>.netrc</code> file (typically stored in a user’s home directory).
With <a href="https://hurl.dev/docs/manual.html#netrc"><code>--netrc</code></a> option, you can tells Hurl to look for and use the <code>.netrc</code> file. <a href="https://hurl.dev/docs/manual.html#netrc-file"><code>--netrc-file</code></a> is similar to <code>--netrc</code>, except that you can provide the path to the actual file to use.</p>
<pre><code class="language-shell">$ hurl --test --netrc-file /home/foo/.netrc *.hurl
</code></pre>
<h3>Per request &ndash;user</h3>
<p>Let’s keep talking about curl options. Like curl, one can use the command line option <a href="https://hurl.dev/docs/manual.html#user"><code>--user</code></a>
to add basic authentication to all the requests of a Hurl file:</p>
<pre><code class="language-shell">$ hurl --user bob:secret login.hurl
</code></pre>
<p><code>--user</code> option can now be set <em>per request</em>, in an <a href="https://hurl.dev/docs/request.html#options"><code>[Options]</code> section</a>:</p>
<pre><code class="language-hurl"># Login with Bob is OK
POST http://foo.com/login
[Options]
user: bob:secret
location: true
HTTP 200

# Login with Alice is KO
POST http://foo.com/login
[Options]
user: alice:secret
location: true
HTTP 401
</code></pre>
<p><code>--user</code> is useful when using <a href="https://docs.aws.amazon.com/AmazonS3/latest/API/sig-v4-authenticating-requests.html">AWS Signature Version 4</a>: Amazon S3 authenticated sessions can be set now per
request:</p>
<pre><code class="language-hurl">GET https://foo.execute-api.us-east-1.amazonas.com/dev/bafe12
[Options]
aws-sigv4: aws:amz:eu-central-1:foo
user: someAccessKeyId:someSecretKey
HTTP 200
</code></pre>
<p>And, last but not least, <code>--user</code> option can use <a href="https://hurl.dev/docs/templates.html#injecting-variables">variables</a>:</p>
<pre><code class="language-hurl">GET https://foo.execute-api.us-east-1.amazonas.com/dev/bafe12
[Options]
aws-sigv4: aws:amz:eu-central-1:foo
user: {{login}}:{{password}}
HTTP 200
</code></pre>
<p>Like many other Hurl option, <code>--user</code> option can be used in the command line (take effect for all requests of a Hurl
file), or per request, with an <code>[Options]</code> section:</p>
<pre><code class="language-hurl">GET https://example.org
# An options section, each option is optional and applied only to this request...
[Options]
aws-sigv4: aws:amz:sts  # generate AWS SigV4 Authorization header
cacert: /etc/cert.pem   # custom certificate file
compressed: true        # request a compressed response
delay: 3000             # delay in ms for this request
http3: true             # use HTTP/3 protocol version
insecure: true          # allow insecure SSL connections and transfers
ipv6: true              # use IPv6 addresses
location: true          # follow redirection for this request
max-redirs: 10          # maximum number of redirections
output: out.html        # dump the response to this file
path-as-is: true        # do not handle sequences of /../ or /./ in URL path
skip: false             # skip this request
unix-socket: sock       # use Unix socket for transfer
user: bob:secret        # use basic authentication
variable: country=Italy # define variable country
variable: planet=Earth  # define variable planet
verbose: true           # allow verbose output
very-verbose: true      # allow more verbose output
</code></pre>
<p>The <a href="https://hurl.dev/docs/manual.html#options">options documentation</a> and the Hurl man page have been improved to show which option can be used only in command line
and which option can be used in command line <em>and</em> in an <code>[Options]</code> section. When option can only be used in command line
the option is tagged &ldquo;cli-only option&rdquo;. For instance:</p>
<pre><code>--color
    Colorize debug output (the HTTP response output is not colorized).
    This is a cli-only option.
</code></pre>
<p>When &ldquo;cli-only option&rdquo; is not specified, the option can be set per request within an <a href="https://hurl.dev/docs/request.html#options"><code>[Options]</code></a> section.</p>
<h3>&ndash;max-filesize</h3>
<p>One last new option backported from curl, <a href="https://hurl.dev/docs/manual.html#max-filesize"><code>--max-filesize</code></a> allows to limit the size of HTTP response data (in bytes):</p>
<pre><code class="language-shell">$ hurl --max-filesize 100000 https://example.com/
</code></pre>
<h3>New Predicates: isNumber, isIsoDate</h3>
<p><a href="https://hurl.dev/docs/asserting-response.html#predicates">Predicates</a> are used to check HTTP responses:</p>
<pre><code class="language-hurl">GET http://httpbin.org/json
HTTP 200
[Asserts]
jsonpath "$.slideshow.author" == "Yours Truly"
jsonpath "$.slideshow.slides[0].title" contains "Wonder"
jsonpath "$.slideshow.slides" count == 2
jsonpath "$.slideshow.date" != null
jsonpath "$.slideshow.slides[*].title" includes "Mind Blowing!"
</code></pre>
<p>Two new predicates are introduced with 4.3.0:</p>
<ul>
<li><code>isNumber</code>: a companion to <code>isInteger</code> / <code>isFloat</code> existing predicates to test if a certain value is a number</li>
<li><code>isIsoDate</code>: check if a string value conforms to the <a href="https://www.rfc-editor.org/rfc/rfc3339">RFC-3339</a> date format <code>YYYY-MM-DDTHH:mm:sssZ</code></li>
</ul>
<pre><code class="language-hurl">GET http://httpbin.org/json
HTTP 200
[Asserts]
jsonpath "$.slideshow.version" isNumber
jsonpath "$.slideshow.date" isIsoDate
jsonpath "$.slideshow.date" == "1937-01-01T12:00:27.87+00:20"
</code></pre>
<h2>Shell Completion</h2>
<p>Hurl now offers shell completion scripts for various shell: <a href="https://ftp.gnu.org/gnu/bash/">bash</a>, <a href="https://fishshell.com">fish</a>, <a href="https://ohmyz.sh">zsh</a> and <a href="https://learn.microsoft.com/en-us/powershell/">PowerShell</a>. Usually, packet
managers package the completion scripts, but you can still install it yourself from <a href="https://github.com/Orange-OpenSource/hurl/tree/master/completions">Hurl’s GitHub repository</a>.</p>
<h2>One More Thing...</h2>
<p>One last thing, and this is a pretty big thing (at least for us <picture><source srcset="https://hurl.dev/assets/img/emoji-smiling-face.avif" type="image/avif"><source srcset="https://hurl.dev/assets/img/emoji-smiling-face.webp" type="image/webp"><source srcset="https://hurl.dev/assets/img/emoji-smiling-face.png" type="image/png"><img class="emoji" src="https://hurl.dev/assets/img/emoji-smiling-face.png" width="20" height="20" alt="Surfer"></picture>) !</p>
<p>In Hurl 4.3.0, we’ve addressed <a href="https://github.com/Orange-OpenSource/hurl/issues/87">one of our oldest issue</a>, proposed in 2020: <strong>a <code>--parallel</code> option!</strong></p>
<p>
    <picture>
        <source srcset="https://hurl.dev/assets/img/pinto-dark.avif" type="image/avif">
        <source srcset="https://hurl.dev/assets/img/pinto-dark.webp" type="image/webp">
        <source srcset="https://hurl.dev/assets/img/pinto-dark.png" type="image/png">
        <img class="u-theme-dark u-drop-shadow u-border u-max-width-100" src="https://hurl.dev/assets/img/pinto-dark.png" width="600" alt="Parallel GitHub issue"/>
    </picture>
</p>

<p>It has been a long run since this issue, but we always kept in our mind that, at a moment, we want to be able to
run Hurl files in parallel. Now, with 4.3.0, we’re introducing an opt-in <a href="https://hurl.dev/docs/manual.html#parallel"><code>--parallel</code></a>
option that will enable parallel
execution of Hurl files.</p>
<p>In Hurl 4.3.0, running files in test mode is (no change):</p>
<pre><code class="language-shell">$ hurl --test *.hurl
</code></pre>
<p>With <code>--parallel</code>, you can choose to run your tests in parallel:</p>
<pre><code class="language-shell">$ hurl --test --parallel *.hurl
</code></pre>
<p>To develop this feature, we take a lot of inspiration of the venerable <a href="https://www.gnu.org/software/parallel/">GNU Parallel</a>.</p>
<p>In the parallel mode, each Hurl file is executed on its own thread, sharing nothing with other jobs. There is a thread
pool which size is roughly the current amount of CPUs and that can be configured with <a href="https://hurl.dev/docs/manual.html#jobs"><code>--jobs</code></a> option. During parallel execution, standard output and error are buffered for each file and only displayed on screen when a job file is finished. This way, debug logs and messages are never interleaved between execution. Order of execution is not guaranteed
in <code>--parallel</code> mode but reports (<a href="https://hurl.dev/docs/running-tests.html#html-report">HTML</a>, <a href="https://hurl.dev/docs/running-tests.html#tap-report">TAP</a>, <a href="https://hurl.dev/docs/running-tests.html#junit-report">JUnit</a>) keep the input files order.</p>
<p>The parallelism used is multithread sync: the thread pool is instantiated for the whole run, each Hurl file is run
in its own thread, synchronously . We’ve not gone through the full multithreaded async route for implementation
simplicity. Moreover, there is no additional dependency, only the standard Rust lib with &ldquo;classic&rdquo; threads and
<a href="https://doc.rust-lang.org/book/ch16-02-message-passing.html">multiple producers / single consumer channels</a> to communicate between threads.</p>
<p>For the 4.3.0, we’ve marked the <code>--parallel</code> option as &ldquo;experimental&rdquo; as we want to have feedbacks on it and insure that
everything works as designed. We plan to make this mode of execution the default when executing Hurl files with <code>--test</code>
in the Hurl 5.0.0 version.</p>
<p>Give it a try, if you think Hurl is fast, Oh Boy... Wait until you see the new parallel mode!   </p>
<h2>Others</h2>
<p>There are a lot other improvements with Hurl 4.3.0 and also a lot of bug fixes,
you can check the complete list of enhancements and bug fixes <a href="https://github.com/Orange-OpenSource/hurl/releases/tag/4.3.0">in our release note</a>.</p>
<p>If you like Hurl, don’t hesitate to <a href="https://github.com/Orange-OpenSource/hurl/stargazers">give us a star on GitHub</a> or share it on <a href="https://twitter.com/HurlDev">Twitter</a>!</p>
<p>We’ll be happy to hear from you, either for enhancement requests or for sharing your success story using Hurl!</p>]]></content>
        <author>
            <name/>
        </author>
        <summary/>
    </entry>
    <entry>
        <title>Hurl 4.2.0, the HTTP/3 Edition</title>
        <link href="https://hurl.dev/blog/2024/01/12/hurl-4.2.0-the-http3-edition.html" rel="alternate" type="text/html" title="Hurl 4.2.0, the HTTP/3 Edition"/>
        <published>2024-01-12T00:00:00+01:00</published>
        <updated>2024-01-12T00:00:00+01:00</updated>
        <id>https://hurl.dev/blog/2024/01/12/hurl-4.2.0-the-http3-edition.html</id>
        <content type="html"><![CDATA[<h1>Hurl 4.2.0, the HTTP/3 Edition</h1>
<div class="blog-post-date">Jan. 12, 2024</div>

<p>
<picture>
    <source srcset="https://hurl.dev/assets/img/hurl-http3.avif" type="image/avif">
    <source srcset="https://hurl.dev/assets/img/hurl-http3.webp" type="image/webp">
    <source srcset="https://hurl.dev/assets/img/hurl-http3.png" type="image/png">
    <img class="u-drop-shadow u-border" src="https://hurl.dev/assets/img/hurl-http3-light.png" width="100%" alt="Hurl loves HTTP3"/>
</picture>
</p>

<p>The Hurl team is thrilled to announce <a href="https://github.com/Orange-OpenSource/hurl/releases/tag/4.2.0">Hurl 4.2.0</a> <picture><source srcset="https://hurl.dev/assets/img/emoji-rocket.avif" type="image/avif"><source srcset="https://hurl.dev/assets/img/emoji-rocket.webp" type="image/webp"><source srcset="https://hurl.dev/assets/img/emoji-rocket.png" type="image/png"><img class="emoji" src="https://hurl.dev/assets/img/emoji-rocket.png" width="20" height="20" alt="Rocket"></picture> !</p>
<p><a href="https://hurl.dev">Hurl</a> is a command line tool powered by <a href="https://curl.se">curl</a>, that runs HTTP requests defined in a simple plain text format:</p>
<pre><code class="language-hurl">GET https://example.org/api/tests/4567
HTTP 200
[Asserts]
header "x-foo" contains "bar"
certificate "Expire-Date" daysAfterNow &gt; 15
jsonpath "$.status" == "RUNNING"    # Check the status code
jsonpath "$.tests" count == 25      # Check the number of items
jsonpath "$.id" matches /\d{4}/     # Check the format of the id
</code></pre>
<h2>What’s New in This Release</h2>
<ul>
<li><a href="#http3-support">HTTP/3 Support</a></li>
<li><a href="#install-with-conda-forge">Install With conda-forge</a></li>
<li><a href="#save-response-per-request">Save Response per Request</a></li>
<li><a href="#jsonpath-filter">jsonpath Filter</a></li>
<li><a href="#more-curl-options-ipv6ipv4-unix-socket-etc">More curl options: IPv6/IPv4, unix-socket etc...</a></li>
<li><a href="#others">Others</a></li>
</ul>
<h2>HTTP/3 Support</h2>
<p>Hurl HTTP engine is powered by <a href="https://curl.se">curl</a>, one of the most reliable HTTP libraries, available in millions of softwares, devices
(TVs, cars, printers etc..), and is <a href="https://daniel.haxx.se/blog/2021/12/03/why-curl-is-used-everywhere-even-on-mars/">even used on Mars</a>. In details, Hurl is written in Rust, offloading the HTTP
layer to <a href="https://curl.se/libcurl/">libcurl</a>. We like this design a lot because Hurl benefits directly from curl’s power and capabilities &ldquo;for
free&rdquo;, adding some nice <a href="https://hurl.dev/docs/asserting-response.html">asserts</a> and <a href="https://hurl.dev/docs/capturing-response.html">captures</a> possibilities to chain and test HTTP requests.</p>
<p>Started with <a href="https://github.com/Orange-OpenSource/hurl/releases/tag/4.2.0">Hurl 4.2.0</a>, Hurl supports now <a href="https://en.wikipedia.org/wiki/HTTP/3">HTTP/3</a>! Running a Hurl file with HTTP/3 can be done on the command line,
with [<code>--http3</code>] option:</p>
<pre><code class="language-shell">$ hurl --http3 test.hurl
</code></pre>
<p>Like curl, there are also [<code>--http2</code>], [<code>--http1.1</code>] and [<code>--http1.0</code>] options to force a certain version of HTTP. With
<a href="https://hurl.dev/docs/request.html#options">options sections</a>, we can specify an HTTP version per request, in the same Hurl file:</p>
<pre><code class="language-hurl">GET https://myserver.com
[Options]
http3: true
HTTP/3 200

GET https://myserver.com
[Options]
http2: true
HTTP/2 200
</code></pre>
<p>To use HTTP/3, the underlying libcurl used by Hurl must expose HTTP/3 features. Simply run <code>hurl --version</code> to check
which libcurl features are supported:</p>
<pre><code class="language-shell">$ hurl --version
hurl 4.2.0 (x86_64-apple-darwin23.0) libcurl/8.1.2 (SecureTransport) LibreSSL/3.3.6 zlib/1.2.12 nghttp2/1.55.1
Features (libcurl):  alt-svc AsynchDNS HSTS HTTP2 HTTP3 IPv6 Largefile libz NTLM NTLM_WB SPNEGO SSL UnixSockets
Features (built-in): brotli
</code></pre>
<blockquote>
<p>If installed on macOS with <a href="https://brew.sh">Homebrew</a>, Hurl uses the system libcurl that does not support HTTP/3 yet. To use HTTP/3 on macOS,
you can: </p>
<ol>
<li>compile your own version of libcurl to support HTTP/3. Cloudflare has a simple Homebrew formula to <a href="https://github.com/cloudflare/homebrew-cloudflare/blob/master/curl.rb">build libcurl with HTTP/3</a></li>
<li><a href="https://hurl.dev/docs/frequently-asked-questions.html#how-can-i-use-a-custom-libcurl-from-homebrew-by-instance">link Hurl with this updated libcurl</a></li>
<li>Enjoy!</li>
</ol>
</blockquote>
<p>There are very few HTTP clients that support HTTP/3, so we’re very happy with this new feature and look forward for
feedbacks!</p>
<h2>Install With conda-forge</h2>
<p>Thanks to <a href="https://twitter.com/humphd">@humphd</a>, a recurring provider of new features, Hurl can now be installed through <a href="https://conda-forge.org">conda-forge</a>, a
community-led packet manager for Conda:</p>
<pre><code class="language-shell">$ conda install -c conda-forge hurl
</code></pre>
<p>conda-forge Hurl installation supports macOS, Linux, Windows, on x86 and ARM 64 bits architectures so we’ve got you
covered!</p>
<p>What’s very interesting with conda-forge is that other packet managers use it as a distribution source. For instance,
<a href="https://pixi.sh">pixi</a>, a powerful and fast package management tool, uses the existing conda ecosystem, so Hurl can be installed
with pixi:</p>
<pre><code class="language-shell">$ pixi init hello-world
$ cd hello-world
$ pixi add hurl
</code></pre>
<p>There are, of course, a lot of <a href="https://hurl.dev/docs/installation.html">other ways to install Hurl</a>. If your preferred platform is not yet supported, drop-us
<a href="https://github.com/Orange-OpenSource/hurl/issues">an issue on GitHub</a>!</p>
<h2>Save Response per Request</h2>
<p>Hurl can be used as a <a href="https://hurl.dev/docs/tutorial/adding-asserts.html">testing tool</a>, but it can be also simply used to get HTTP response when you’ve to chain multiple
dependant requests (download a resource behind a login for instance). In a Hurl file, you can chain multiple requests,
passing data from one to another:</p>

<pre><code class="language-hurl"># Get home:
GET https://example.org
HTTP 200
[Captures]
csrf_token: xpath "string(//meta[@name='_csrf_token']/@content)"

# Do login!
POST https://example.org/login?user=toto&amp;password=1234
X-CSRF-TOKEN: {{csrf_token}}
HTTP 302

# Get our precisous resource:
GET https://example.org/protected
HTTP 200
</code></pre>

<p>When run, Hurl outputs the last response body on the standard output (in this case the response of
<code>GET https://example.org/protected</code>). Like curl, this response can be saved to a file with [<code>--output</code>] option:</p>
<pre><code class="language-shell">$ hurl --output /tmp/response.json api.hurl
</code></pre>
<p>With <a href="https://hurl.dev/docs/request.html#options">options sections</a>, we can now save to file each individual response of
any request. </p>
<p>Let’s imagine we have a cat API that returns a JSON response for a given cat. If we want to
save multiple cat images on disk, we can write this Hurl file:</p>
<ol>
<li>Get the JSON response data for our first cat</li>
<li>Extract the image’s URL of this cat</li>
<li>Save it to disk with [<code>--output</code>]</li>
<li>Get the JSON response data for our second cat</li>
<li>Extract the image’s URL of this cat</li>
<li>Save it to disk with [<code>--output</code>]</li>
<li>Repeat...</li>
</ol>
<p>Our Hurl file will look like this:</p>

<pre><code class="language-hurl"># Get our first cat resource and capture its image
GET https://catapi.com/cats/1
HTTP 200
[Captures]
img: jsonpath "$.url"

# Download its image and save it to disk
GET {{img}}
[Options]
output: cat1.jpg
HTTP 200

# Do the same with the second cat:
GET https://catapi.com/cats/2
HTTP 200
[Captures]
img: jsonpath "$.url"

# Download its image and save it to disk
GET {{img}}
[Options]
output: cat2.jpg
HTTP 200
</code></pre>

<h2>jsonpath Filter</h2>
<p>Data can be captured and/or tested from HTTP responses using <a href="https://hurl.dev/docs/asserting-response.html#jsonpath-assert">JSONPath</a>, <a href="https://hurl.dev/docs/asserting-response.html#xpath-assert">XPath</a>, <a href="https://hurl.dev/docs/asserting-response.html#regex-assert">regex</a> etc... <a href="https://hurl.dev/docs/filters.html">Filters</a> allow us to
even refine the extracted data. With the [new <code>jsonpath</code> filter], we’re able to chain XPath or regex queries with a
JSONPath filter:</p>
<p>For instance, given this HTML file:</p>
<pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;body&gt;

&lt;p id="user"&gt;&lt;/p&gt;

&lt;script&gt;
var s = '{"first_name" : "Sammy", "last_name" : "Shark", "location" : "Ocean"}';

var obj = JSON.parse(s);

document.getElementById("user").innerHTML =
"Name: " + obj.first_name + " " + obj.last_name + "&lt;br&gt;" +
"Location: " + obj.location;
&lt;/script&gt;

&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p>We want to extract the string <code>{"first_name" : "Sammy", "last_name" : "Shark", "location" : "Ocean"}</code> and analyse it as
a JSON:</p>
<ol>
<li>First, with a [<code>regex</code> query], we extract this string  <br />
<code>regex /var s = '(.*)';/</code></li>
<li>Then, with a [<code>jsonpath</code> filter], we test the data  <br />
<code>jsonpath "$.first_name" == "Sammy"</code></li>
</ol>
<p>So our Hurl file will be:</p>
<pre><code class="language-hurl">GET https://example.com/test.html
HTTP 200
[Asserts]
regex /var s = '(.*)';/ jsonpath "$.first_name" == "Sammy"
regex /var s = '(.*)';/ jsonpath "$.last_name" == "Shark"
regex /var s = '(.*)';/ jsonpath "$.location" == "Ocean"
</code></pre>
<p>Or with an intermediate <a href="https://hurl.dev/docs/capturing-response.html">capture</a>:</p>
<pre><code class="language-hurl">GET https://example.com/test.html
HTTP 200
[Captures]
s: regex /var s = '(.*)';/
[Asserts]
variable "s" jsonpath "$.first_name" == "Sammy"
variable "s" jsonpath "$.last_name" == "Shark"
variable "s" jsonpath "$.location" == "Ocean"
</code></pre>
<p>Check out <a href="https://hurl.dev/docs/filters.html">all the available filters</a> to get the data you want from the HTTP responses.</p>
<h2>More curl options: IPv6/IPv4, unix-socket etc...</h2>
<p>Finally, in Hurl 4.2.0, more curl options have been implemented [<code>--ipv4</code> / <code>--ipv6</code>], [<code>--unix-socket</code>] and
[<code>--location-trusted</code>].</p>
<h3><code>--ipv4</code> / <code>--ipv6</code></h3>
<p>In a shell:</p>
<pre><code class="language-shell">$ hurl --ipv6 foo.hurl
</code></pre>
<p>Or for a specific request in a Hurl file:</p>
<pre><code class="language-hurl">GET https://foo.com
[Options]
ipv6: true
HTTP 200

GET https://foo.com
[Options]
ipv4: true
HTTP 200
</code></pre>
<h3><code>--unix-socket</code></h3>
<p>In a shell:</p>
<pre><code class="language-shell">$ hurl --unix-socket pid bar.hurl
</code></pre>
<p>Or for a specific request in a Hurl file:</p>
<pre><code class="language-hurl">GET https://bar.com
[Options]
unix-socket: "pid"
HTTP 200
</code></pre>
<h3><code>--location-trusted</code></h3>
<p>In a shell:</p>
<pre><code class="language-shell">$ hurl --location-trusted baz.hurl
</code></pre>
<p>Or for a specific request in a Hurl file:</p>
<pre><code class="language-hurl">GET https://baz.com
[Options]
location-trusted: true
HTTP 200
</code></pre>
<p>All the options can, of course, be combined on a specific request:</p>
<pre><code class="language-hurl">GET https://baz.com
[Options]
ipv6: true
location-trusted: true
skip: false
HTTP 200
</code></pre>
<h2>Others</h2>
<p>There are other improvements with Hurl 4.2.0 (dark mode for HTML report, skip option request, etc...) and also a lot of bug fixes,
you can check the complete list of enhancements and bug fixes <a href="https://github.com/Orange-OpenSource/hurl/releases/tag/4.2.0">in our release note</a>.</p>
<p>If you like Hurl, don’t hesitate to <a href="https://github.com/Orange-OpenSource/hurl/stargazers">give us a star on GitHub</a> or share it on <a href="https://twitter.com/HurlDev">Twitter</a>!</p>
<p>We’ll be happy to hear from you, either for enhancement requests or for sharing your success story using Hurl!</p>]]></content>
        <author>
            <name/>
        </author>
        <summary>The Hurl team is thrilled to announce Hurl 4.2.0</summary>
    </entry>
    <entry>
        <title>Announcing Hurl 4.1.0</title>
        <link href="https://hurl.dev/blog/2023/09/24/announcing-hurl-4.1.0.html" rel="alternate" type="text/html" title="Announcing Hurl 4.1.0"/>
        <published>2023-09-24T00:00:00+02:00</published>
        <updated>2023-09-24T00:00:00+02:00</updated>
        <id>https://hurl.dev/blog/2023/09/24/announcing-hurl-4.1.0.html</id>
        <content type="html"><![CDATA[<h1>Announcing Hurl 4.1.0</h1>
<div class="blog-post-date">Sep. 24, 2023</div>

<p>The Hurl team is happy to announce <a href="https://github.com/Orange-OpenSource/hurl/releases/tag/4.1.0">Hurl 4.1.0</a> <picture><source srcset="https://hurl.dev/assets/img/emoji-rocket.avif" type="image/avif"><source srcset="https://hurl.dev/assets/img/emoji-rocket.webp" type="image/webp"><source srcset="https://hurl.dev/assets/img/emoji-rocket.png" type="image/png"><img class="emoji" src="https://hurl.dev/assets/img/emoji-rocket.png" width="20" height="20" alt="Rocket"></picture> !</p>
<p><a href="https://hurl.dev">Hurl</a> is a command line tool powered by <a href="https://curl.se">curl</a>, that runs HTTP requests defined
in a simple plain text format:</p>
<pre><code class="language-hurl">GET https://example.org/api/tests/4567

HTTP 200
[Asserts]
header "x-foo" contains "bar"
certificate "Expire-Date" daysAfterNow &gt; 15
jsonpath "$.status" == "RUNNING"    # Check the status code
jsonpath "$.tests" count == 25      # Check the number of items
jsonpath "$.id" matches /\d{4}/     # Check the format of the id
</code></pre>
<p>What’s new in this release:</p>
<ul>
<li><a href="#tap-report">TAP Report</a></li>
<li><a href="#add-delay-between-requests">Add Delay Between Requests</a></li>
<li><a href="#-connect-to-and-resolve-per-request-option"><code>--connect-to</code> and <code>--resolve</code> per Request Option</a></li>
<li><a href="#aws-signature-version-4">AWS Signature Version 4</a></li>
<li><a href="#arm-64-bits-docker-image">ARM 64 bits Docker Image</a></li>
</ul>
<h2>TAP Report</h2>
<p>We’ve added a new test report: TAP, the <a href="https://testanything.org">Test Anything Protocol</a>. TAP is a simple text-based
interface between testing modules in a test harness. With <a href="https://hurl.dev/docs/running-tests.html#html-report">HTML report</a> and <a href="https://hurl.dev/docs/running-tests.html#junit-report">JUnit report</a>, Hurl supports now
<a href="https://hurl.dev/docs/running-tests.html#tap-report">TAP report</a>.</p>
<p>Let’s say we run some tests. We can use <code>--report-tap REPORT-FILE</code> option to set the report TAP file. If the report file
exists, results will be appended to it.</p>
<pre><code class="language-shell">$ hurl --test --report-tap report.txt *.hurl
add-favorite.hurl: Running [1/6]
add-favorite.hurl: Success (7 request(s) in 5516 ms)
basic.hurl: Running [2/6]
basic.hurl: Success (7 request(s) in 1537 ms)
csrf.hurl: Running [3/6]
error: Assert status code
  --&gt; csrf.hurl:3:6
   |
 3 | HTTP 301
   |      ^^^ actual value is &lt;200&gt;
   |

csrf.hurl: Failure (2 request(s) in 5527 ms)
login.hurl: Running [4/6]
login.hurl: Success (3 request(s) in 3091 ms)
perf.hurl: Running [5/6]
perf.hurl: Success (4 request(s) in 1317 ms)
security.hurl: Running [6/6]
security.hurl: Success (5 request(s) in 2278 ms)
write tap report report.txt
--------------------------------------------------------------------------------
Executed files:  6
Succeeded files: 5 (83.3%)
Failed files:    1 (16.7%)
Duration:        19304 ms
</code></pre>
<p>Then, we can see what our TAP report looks like:</p>
<pre><code class="language-shell">$ cat report.txt
1..6
ok 1 - add-favorite.hurl
ok 2 - basic.hurl
not ok 3 - csrf.hurl
ok 4 - login.hurl
ok 5 - perf.hurl
ok 6 - security.hurl
</code></pre>
<p>Simple and neat! TAP has wide support across many language and there are many tools that can convert TAP
to other formats, so it’s a nice addition to Hurl!</p>
<h2>Add Delay Between Requests</h2>
<p>With the new <a href="https://hurl.dev/docs/manual.html#delay"><code>--delay</code> option</a>, you can add a delay between requests:</p>
<pre><code class="language-shell">$ hurl --delay 2000 --test *.hurl
</code></pre>
<p>This command add a 2 seconds delay between each request. As with a lot of Hurl command line options, you
can specify a delay for a single request, with an <a href="https://hurl.dev/docs/request.html#options"><code>[Options]</code> section</a>,
without impacting other requests:</p>
<pre><code class="language-hurl">GET https://foo.com/a
HTTP 200

# This next request will be runned 5s after the
# first one
GET https://foo.com/b
[Options]
delay: 5000
HTTP 200
</code></pre>
<h2>&ndash;connect-to and &ndash;resolve per Request Option</h2>
<p>Speaking of <a href="https://hurl.dev/docs/request.html#options"><code>[Options]</code> sections</a>, <a href="https://hurl.dev/docs/manual.html#connect-to"><code>--connect-to</code></a>
and <a href="https://hurl.dev/docs/manual.html#resolve"><code>--resolve</code></a> can now be specified per request:</p>
<pre><code class="language-hurl">GET https://foo.com/a
[Options]
connect-to: foo.com:80:localhost:8000
HTTP 200

# --resolve option allow to us custom address for a specific host and port pair.
GET http://foo.com:8000/resolve
[Options]
resolve: foo.com:8000:127.0.0.1
HTTP 200
</code></pre>
<p>As of Hurl 4.1.0, the <a href="https://hurl.dev/docs/request.html#options"><code>[Options]</code> section</a> supports:</p>
<pre><code class="language-hurl">GET https://example.org
# An options section, each option is optional and applied only to this request...
[Options]
aws-sigv4: aws:amz:sts  # generate AWS SigV4 Authorization header
cacert: /etc/cert.pem   # a custom certificate file
compressed: true        # request a compressed response
insecure: true          # allows insecure SSL connections and transfers
location: true          # follow redirection for this request
max-redirs: 10          # maximum number of redirections
path-as-is: true        # tell curl to not handle sequences of /../ or /./ in the given URL path
variable: country=Italy # define variable country
variable: planet=Earth  # define variable planet
verbose: true           # allow verbose output
very-verbose: true      # allow more verbose output
</code></pre>
<p>If you need an Hurl command line option (which make sense for a single request) to be on this list, don’t
hesitate to <a href="https://github.com/Orange-OpenSource/hurl/issues">fill an issue</a>!</p>
<h2>AWS Signature Version 4</h2>
<p>Every interaction with Amazon S3 is either authenticated or anonymous. Authenticating to AWS
is done through <a href="https://docs.aws.amazon.com/AmazonS3/latest/API/sig-v4-authenticating-requests.html">AWS Signature Version 4</a>. With <a href="https://hurl.dev/docs/manual.html#aws-sigv4"><code>--aws-sigv4</code></a>,
you can use AWS Signature Version 4 to authenticate your requests</p>
<pre><code class="language-shell">$ hurl --user someAccessKeyId:someSecretKey \
 --aws-sigv4 aws:amz:eu-central-1:foo \
 file.hurl
</code></pre>
<p>And of course, <code>--aws-sigv4</code> can be specified for a single request:</p>
<pre><code class="language-hurl">GET https://foo.execute-api.us-east-1.amazonas.com/dev/bafe12
[Options]
aws-sigv4: aws:amz:eu-central-1:foo
HTTP 200
</code></pre>
<h2>ARM 64 bits Docker Image</h2>
<p>Hurl can be <a href="https://hurl.dev/docs/installation.html">installed as a native binary</a> on a large number of platforms. We also provide
a <a href="https://github.com/Orange-OpenSource/hurl/pkgs/container/hurl">Docker image</a>. Since 4.1.0, Hurl Docker’s image is a <a href="https://www.docker.com/blog/multi-arch-build-and-images-the-simple-way/">multi-arch build</a>: along x86 architectures,
the image supports now ARM 64 bits targets such as Raspberry Pis, AWS A1 instances or even ARM’s Apple computers.</p>
<pre><code class="language-shell">$ docker run -v /tmp/:/tmp/ ghcr.io/orange-opensource/hurl:4.1.0 --test example.hurl
example.hurl: Running [1/1]
example.hurl: Success (1 request(s) in 190 ms)
--------------------------------------------------------------------------------
Executed files:  1
Succeeded files: 1 (100.0%)
Failed files:    0 (0.0%)
Duration:        193 ms
</code></pre>
<h2>Others</h2>
<p>Changes that require a particular attention:</p>
<ul>
<li>we have renamed <code>--fail-at-end</code> option to
<a href="https://hurl.dev/docs/manual.html#continue-on-error"><code>--continue-on-error</code></a> as the latter is more
understandable</li>
<li>we have fixed <a href="https://hurl.dev/docs/manual.html#path-as-is"><code>--path-as-is</code></a> option name (instead of <code>--path_as_is</code>)</li>
</ul>
<p>There are other improvements and bug fixes, you can check a complete list <a href="https://github.com/Orange-OpenSource/hurl/releases/tag/4.1.0">in our release note</a>.
If you like Hurl, don’t hesitate to <a href="https://github.com/Orange-OpenSource/hurl/stargazers">give us a star on GitHub</a> or share it on <a href="https://twitter.com/HurlDev">Twitter / X</a>!</p>
<p>We’ll be happy to hear from you, either for enhancement requests or for sharing your success story using Hurl!</p>]]></content>
        <author>
            <name/>
        </author>
        <summary>The Hurl team is happy to announce a new version of Hurl, 4.1.0.</summary>
    </entry>
    <entry>
        <title>Announcing Hurl 4.0.0</title>
        <link href="https://hurl.dev/blog/2023/06/30/announcing-hurl-4.0.0.html" rel="alternate" type="text/html" title="Announcing Hurl 4.0.0" />
        <published>2023-06-30T00:00:00+02:00</published>
        <updated>2023-06-30T00:00:00+02:00</updated>
        <id>https://hurl.dev/blog/2023/06/30/announcing-hurl-4.0.0.html</id>
        <content type="html"><![CDATA[<h1 id="announcing-hurl-400">Announcing Hurl 4.0.0</h1>

<div class="blog-post-date">Jun. 30, 2023</div>

<p>The Hurl team is happy to announce <a href="https://github.com/Orange-OpenSource/hurl/releases/tag/4.0.0">Hurl 4.0.0</a> <picture><source srcset="/assets/img/emoji-party-popper.avif" type="image/avif" /><source srcset="/assets/img/emoji-party-popper.webp" type="image/webp" /><source srcset="/assets/img/emoji-party-popper.png" type="image/png" /><img class="emoji" src="/assets/img/emoji-party-popper.png" width="20" height="20" alt="Partying Face" /></picture> !</p>

<p><a href="https://hurl.dev">Hurl</a> is a command line tool powered by <a href="https://curl.se">curl</a>, that runs HTTP requests defined
in a simple plain text format:</p>

<pre><code class="language-hurl">GET https://example.org/api/tests/4567

HTTP 200
[Asserts]
header "x-foo" contains "bar"
certificate "Expire-Date" daysAfterNow &gt; 15
jsonpath "$.status" == "RUNNING"    # Check the status code
jsonpath "$.tests" count == 25      # Check the number of items
jsonpath "$.id" matches /\d{4}/     # Check the format of the id
</code></pre>

<p>What’s new in this release:</p>

<ul>
  <li><a href="#improved-html-report-with-request-waterfall">Improved HTML Report with Request Waterfall</a></li>
  <li><a href="#detailed-error-for-cicd">Detailed Error for CI/CD</a></li>
  <li><a href="#new-filters-decode-and-xpath">New Filters: decode and xpath</a></li>
  <li><a href="#jsonpath-change">JSONPath Change</a></li>
  <li><a href="#custom-http-methods">Custom HTTP Methods</a></li>
</ul>

<h2 id="improved-html-report-with-request-waterfall">Improved HTML Report with Request Waterfall</h2>

<p>We’ve improved <a href="/docs/manual.html#report-html">Hurl HTML report</a>. The HTML report is pure HTML, without any JavaScript and with inlined CSS, so it’s should be
easy to integrate in your favorite CI/CD solution (like <a href="https://docs.gitlab.com/ee/ci/">GitLab CI/CD</a> or <a href="https://github.com/features/actions">GitHub Actions</a> for instance). Now, each run produces:</p>

<ul>
  <li>a <strong>waterfall timeline</strong>: each request/response is displayed on a beautiful graph, with easy access to response timings (DNS,
TCP handshake, time to first byte etc...). These timings are provided by <code>libcurl</code> and you can find an explanation of each
indicator <a href="/docs/response.html#timings">in the documentation</a></li>
  <li>a run log with request and response headers, certificate info etc...</li>
  <li>a syntax colored source file with inline errors</li>
</ul>

<picture>
  <source srcset="/assets/img/timeline.avif" type="image/avif" />
  <source srcset="/assets/img/timeline.webp" type="image/webp" />
  <source srcset="/assets/img/timeline.png" type="image/png" />
  <img class="u-drop-shadow u-border" src="/assets/img/timeline.png" width="100%" alt="Requests timeline" />
</picture>

<p>The timings used to construct the requests timeline are also exposed through <a href="/docs/manual.html#json"><code>--json</code> option</a>. <code>--json</code> gives you a structured
view of a Hurl run with errors, asserts, certificates, captures, cookies and so timings. You can even use it to produce your own report!</p>

<h3 id="once-you-see-it-you-cant-unsee-it">Once you see it, you can’t unsee it</h3>

<p>What’s interesting with rich visualisation is it can reveal hidden or not obvious things. For instance, you can have this
kind of gaps on some runs:</p>

<picture>
  <source srcset="/assets/img/asserts-perf.avif" type="image/avif" />
  <source srcset="/assets/img/asserts-perf.webp" type="image/webp" />
  <source srcset="/assets/img/asserts-perf.png" type="image/png" />
  <img class="u-drop-shadow u-border" src="/assets/img/asserts-perf.png" width="734" />
</picture>

<p>After analysis, the gap between requests in this sample test is caused by a huge numbers of assertions on the HTTP response. We have, as of Hurl 4.0.0, a naive
approach of asserts computation: each asserts of the same response is independent, and we parse and recompute every assert from scratch.
Until we see these edge cases, we were very proud of Hurl speed (due to the combination of <code>libcurl</code> and
Rust). Now, we know that we have to improve assert performance for the next release <picture><source srcset="/assets/img/emoji-sad-pensive-face.avif" type="image/avif" /><source srcset="/assets/img/emoji-sad-pensive-face.webp" type="image/webp" /><source srcset="/assets/img/emoji-sad-pensive-face.png" type="image/png" /><img class="emoji" src="/assets/img/emoji-sad-pensive-face.png" width="20" height="20" alt="Sad Pensive Face Emoji" /></picture> !</p>

<h2 id="detailed-error-for-cicd">Detailed Error for CI/CD</h2>

<p>When you’ve error in some test, the analysis can be difficult because you don’t have a lot of information apart of the expected
values:</p>

<pre><code class="language-shell">$ hurl --test test.hurl
test.hurl: Running [1/1]
error: Assert failure
  --&gt; test.hurl:4:0
   |
 4 | header "Control-Security-Policy" contains "default-src 'self'"
   |   actual:   none
   |   expected: contains string &lt;default-src 'self'&gt;
   |

test.hurl: Failure (1 request(s) in 128 ms)
--------------------------------------------------------------------------------
Executed files:  1
Succeeded files: 0 (0.0%)
Failed files:    1 (100.0%)
Duration:        130 ms
</code></pre>

<p>With the new <a href="/docs/manual.html#error-format"><code>--error-format</code> option</a>, you can opt in for a longer error description. In this mode, the response header and the response
body are automatically logged:</p>

<pre><code class="language-shell">$ hurl --error-format long --test test.hurl
test.hurl: Running [1/1]
HTTP/2 200
date: Thu, 29 Jun 2023 16:06:58 GMT
content-type: text/html
content-length: 58941
last-modified: Thu, 29 Jun 2023 14:37:22 GMT
etag: "649d9722-e63d"
strict-transport-security: max-age=31536000; includeSubDomains
content-security-policy: default-src 'self'; script-src 'self' 'unsafe-eval' 'wasm-unsafe-eval'
x-frame-options: SAMEORIGIN
x-content-type-options: nosniff
accept-ranges: bytes

&lt;!DOCTYPE html&gt;
&lt;html lang="en"&gt;
    &lt;head&gt;
        &lt;meta charset="utf-8" /&gt;
&lt;meta name="viewport" content="width=device-width, initial-scale=1" /&gt;
&lt;link rel="apple-touch-icon" href="/assets/img/hurl-icon-120.png" /&gt;
...
...
...
    &lt;/body&gt;
&lt;/html&gt;

error: Assert failure
  --&gt; test.hurl:4:0
   |
 4 | header "Control-Security-Policy" contains "default-src 'self'"
   |   actual:   none
   |   expected: contains string &lt;default-src 'self'&gt;
   |

test.hurl: Failure (1 request(s) in 146 ms)
--------------------------------------------------------------------------------
Executed files:  1
Succeeded files: 0 (0.0%)
Failed files:    1 (100.0%)
Duration:        148 ms
</code></pre>

<p>In this example, we can see that there is actually a <code>Content-Security-Policy</code> whereas we’re querying a <code>Control-Security-Policy</code>
header. The bug is now really simple to solve because the response headers and body are logged.</p>

<p>This option is really useful in CI/CD where you want to have all the available context to debug your session, without
re-running your tests. Beware that, as the body response is logged, the log can be <em>really</em> long.</p>

<h2 id="new-filters-decode-and-xpath">New Filters: decode and xpath</h2>

<p>Textual asserts in Hurl work by automatically decoding the response body bytes, based on the <code>Content-Type</code> response header.
That way, if we have a Latin 1 encoded HTML or an UFT-8 encoded HTML we can write the same assert without any encoding concern:</p>

<pre><code class="language-hurl"># UTF-8 encoded document:
GET https://example.org/charset/utf8
HTTP 200
Content-Type: text/html; charset=utf-8
[Asserts]
body == "&lt;p&gt;café&lt;/p&gt;"

# Latin1 encoded document:
GET https://example.org/charset/latin1
HTTP 200
Content-Type: text/html; charset=latin1
[Asserts]
body == "&lt;p&gt;café&lt;/p&gt;"
</code></pre>

<p>To decode a response from bytes to text, Hurl uses <code>charset</code> hint from <code>Content-Type</code> response header. But sometimes the <code>Content-Type</code>
response header doesn’t specify any encoding. Or the encoding is indicated inside the HTML document through <a href="https://developer.mozilla.org/en-US/docs/Web/HTML/Element/meta#http-equiv"><code>&lt;meta&gt;</code> tag</a>:</p>

<pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html&gt;
    &lt;head&gt;
        &lt;meta http-equiv='Content-Type' content='text/html; charset=gb2312'&gt;
    &lt;/head&gt;
    &lt;body&gt;你好世界&lt;/body&gt;
&lt;/html&gt;
</code></pre>

<p>In this case, a <a href="/docs/filters.html#decode"><code>decode</code> filter</a> can now be used to explicitly decodes bytes to text and do checks:</p>

<pre><code class="language-hurl">GET https://example.com/hello_gb231
HTTP 200
[Asserts]
header "Content-Type" == "text/html"
bytes contains hex,c4e3bac3cac0bde7; # 你好世界 encoded in GB2312
bytes decode "gb2312" xpath "string(//body)" == "你好世界"
</code></pre>

<p>As hinted in the previous Hurl snippet, you can now evaluate XPath expression on response part with a <a href="/docs/filters.html#xpath"><code>xpath</code> filter</a>.</p>

<h2 id="jsonpath-change">JSONPath Change</h2>

<p>In Hurl 4.0.0, we’ve slightly changed the evaluation of <a href="https://goessner.net/articles/JsonPath/">JSONPath</a> query. There is no proper specifications for JSONPath.
The de-facto one, that Hurl tries to follow as closely as possible, is still <a href="https://goessner.net/articles/JsonPath/">https://goessner.net/articles/JsonPath/</a>.
There are a few edge cases for which several implementations differ. For instance, standard JSONPath always returns a collection,
which most of the time is not meaningful, and harder to test. Some implementations (such as the Java library <a href="https://github.com/json-path/JsonPath">https://github.com/json-path/JsonPath</a>)
also distinguish between node value (definite path) and collection (indefinite path).</p>

<p>Basically, in Hurl 4.0.0, the only selectors returning a value are:</p>

<ul>
  <li>array index selector (<code>$.store.book[2]</code>)</li>
  <li>object key selector (<code>$.store.bicycle.color/$.store.bicycle['color']</code>)</li>
</ul>

<p>Other selectors, that use filters (for instance <code>?(@.price &gt;= 10)</code> or <code>$[*].id</code>) will return a collection. You can then use
<a href="/docs/filters.html#nth"><code>nth</code> filter</a> to extract a value from this collection.</p>

<pre><code class="language-hurl">GET https://example.com/books
HTTP 200
[Asserts]
jsonpath "$.store.book[0].title" == "Dune"
jsonpath "$.store.book[*].title" nth 0 == "Dune"
</code></pre>

<h2 id="custom-http-methods">Custom HTTP methods</h2>

<p>Hurl 4.0.0 supports now any custom HTTP method. The only constraint is to write the method in uppercase. You can right-away
experiment the <a href="https://www.ietf.org/archive/id/draft-ietf-httpbis-safe-method-w-body-02.html">incoming new <code>QUERY</code> method</a>:</p>

<pre><code class="language-hurl">QUERY https://example.org/contacts
Content-Type: example/query
Accept: text/csv
HTTP 200
Content-Type: text/csv
```
surname, givenname, email
Smith, John, john.smith@example.org
Jones, Sally, sally.jones@example.com
Dubois, Camille, camille.dubois@example.net
```
</code></pre>

<h2 id="others">Others</h2>

<p>There are other improvements and bug fixes, you can check a complete list <a href="https://github.com/Orange-OpenSource/hurl/releases/tag/4.0.0">in our release note</a>.
If you like Hurl, don’t hesitate to <a href="https://github.com/Orange-OpenSource/hurl/stargazers">give us a star on GitHub</a> or share it on <a href="https://twitter.com/HurlDev">Twitter</a>!</p>

<p>We’ll be happy to hear from you, either for enhancement requests or for sharing your success story using Hurl!</p>]]></content>
        <author><name></name></author>
        <summary>The Hurl team is happy to announce a new version of Hurl, 4.0.0.</summary>
    </entry>
    <entry>
        <title>Announcing Hurl 3.0.0</title>
        <link href="https://hurl.dev/blog/2023/05/05/announcing-hurl-3.0.0.html" rel="alternate" type="text/html" title="Announcing Hurl 3.0.0" />
        <published>2023-05-05T00:00:00+02:00</published>
        <updated>2023-05-05T00:00:00+02:00</updated>
        <id>https://hurl.dev/blog/2023/05/05/announcing-hurl-3.0.0.html</id>
        <content type="html"><![CDATA[<h1 id="announcing-hurl-300">Announcing Hurl 3.0.0</h1>

<div class="blog-post-date">May. 06, 2023</div>

<p>The Hurl team is happy to announce <a href="https://github.com/Orange-OpenSource/hurl/releases/tag/3.0.0">Hurl 3.0.0</a>!</p>

<p><a href="https://hurl.dev">Hurl</a> is a command line tool powered by <a href="https://curl.se">curl</a>, that runs HTTP requests defined
in a simple plain text format:</p>

<pre><code class="language-hurl">GET https://example.org/api/tests/4567

HTTP 200
[Asserts]
header "x-foo" contains "bar"
certificate "Expire-Date" daysAfterNow &gt; 15
jsonpath "$.status" == "RUNNING"    # Check the status code
jsonpath "$.tests" count == 25      # Check the number of items
jsonpath "$.id" matches /\d{4}/     # Check the format of the id
</code></pre>

<p>What’s new in this release:</p>

<ul>
  <li><a href="#checking-ssl-attributes-expiration-date-issuer-etc">Checking SSL Attributes (Expiration Date, Issuer, etc...)</a></li>
  <li><a href="#working-with-date-values">Working with Date Values</a></li>
  <li><a href="#convert-curl-to-hurl">Convert curl to Hurl</a></li>
  <li><a href="#simplify-hurls-rust-apis">Simplify Hurl’s Rust APIs</a></li>
</ul>

<h2 id="checking-ssl-attributes-expiration-date-issuer-etc">Checking SSL Attributes (Expiration Date, Issuer, etc...)</h2>

<p>In Hurl 3.0.0, we can now check various attributes of a SSL certificate:</p>

<pre><code class="language-hurl"># Check attributes of the SSL certificate
GET https://example.org

HTTP 200
[Asserts]
certificate "Subject" == "CN=example.org"
certificate "Issuer" == "C=US, O=Let's Encrypt, CN=R3"
certificate "Expire-Date" daysAfterNow &gt; 15
certificate "Serial-Number" matches /[\da-f]+/
</code></pre>

<p>The following properties are available to check: <code>Subject</code>,  <code>Issuer</code>, <code>Start-Date</code>, <code>Expire-Date</code> and  <code>Serial-Number</code>.
Using certificate asserts, you can simply create a cron job that will warn you if your certificate expires soon.</p>

<p>If you want more information on the SSL layer, you can also use <a href="/docs/manual.html#very-verbose"><code>--very-verbose</code></a> option that will output curl debug logs,
including SSL informations:</p>

<pre><code class="language-shell">$ echo 'HEAD https://hurl.dev' | hurl --very-verbose
* Options:
*     fail fast: true
...
*
* Request can be run with the following curl command:
* curl 'https://hurl.dev' --head
*
**   Trying 145.239.78.213:443...
** Connected to hurl.dev (145.239.78.213) port 443 (#0)
** ALPN, offering h2
** ALPN, offering http/1.1
** successfully set certificate verify locations:
**  CAfile: /etc/ssl/cert.pem
**  CApath: none
** (304) (OUT), TLS handshake, Client hello (1):
** (304) (IN), TLS handshake, Server hello (2):
** TLSv1.2 (IN), TLS handshake, Certificate (11):
** TLSv1.2 (IN), TLS handshake, Server key exchange (12):
** TLSv1.2 (IN), TLS handshake, Server finished (14):
** TLSv1.2 (OUT), TLS handshake, Client key exchange (16):
...
</code></pre>

<h2 id="working-with-date-values">Working with Date Values</h2>

<p>Introduced in <a href="https://hurl.dev/blog/2023/01/25/hurl-2.0.0-the-graphql-edition.html">Hurl 2.0.0</a>, <a href="/docs/filters.html">filters</a> allow you to transform the data extracted from an HTTP response, whether in asserts
or in captures:</p>

<pre><code class="language-hurl">GET https://example.org/api

HTTP 200
[Captures]
name: jsonpath "$user.id" replace /\d/ "x"
[Asserts]
header "x-servers" split "," count == 2
header "x-servers" split "," nth 0 == "rec1"
header "x-servers" split "," nth 1 == "rec3"
jsonpath "$.books" count == 12
</code></pre>

<p>Now, we have filters to work on dates: <a href="/docs/filters.html#daysafternow"><code>daysAfterNow</code></a>, <a href="/docs/filters.html#daysbeforenow"><code>daysBeforeNow</code></a>, <a href="/docs/filters.html#format"><code>format</code></a> and <a href="/docs/filters.html#todate"><code>toDate</code></a>. For instance, let’s say we
have a JSON response like this:</p>

<pre><code class="language-json">{
  "published": "2023-01-23T18:25:43.511Z"
}
</code></pre>

<p>We can do the following:</p>

<ul>
  <li>extract the <code>published</code> string from the response =&gt; <code>jsonpath "$.published"</code></li>
  <li>transform this value to a date variable =&gt; <code>toDate "%Y-%m-%dT%H:%M:%S%.fZ"</code></li>
  <li>reformat this date to the day of the week =&gt; <code>format "%A"</code></li>
</ul>

<p>So, our Hurl test becomes:</p>

<pre><code class="language-hurl">GET https://example.org/books/123
HTTP 200
[Asserts]
jsonpath "$.published" == "2023-01-23T18:25:43.511Z"
jsonpath "$.published" toDate "%Y-%m-%dT%H:%M:%S%.fZ" format "%A" == "Monday"
</code></pre>

<p>ISO 8601 / RFC 3339 date and time format have shorthand format <code>%+</code> so we can write:</p>

<pre><code class="language-hurl">GET https://example.org/books/123
HTTP 200
[Asserts]
jsonpath "$.published" == "2023-01-23T18:25:43.511Z"
jsonpath "$.published" toDate "%+" format "%A" == "Monday"
</code></pre>

<p>Some queries are natively returning date values: <a href="/docs/asserting-response.html#ssl-certificate-assert">expiration date of SSL certificates</a> or <a href="/docs/asserting-response.html#cookie-assert">expiration date of cookies</a> for instance:</p>

<pre><code class="language-hurl">GET https://example.org
HTTP 200
[Asserts]
cookie "LSID[Expires]" format "%a, %d %b %Y %H:%M:%S" == "Thu, 13 Jan 2078 22:23:01"
certificate "Expire-Date" daysAfterNow &gt; 15
</code></pre>

<h2 id="convert-curl-to-hurl">Convert curl to Hurl</h2>

<p><code>hurlfmt</code> is our Swiss knife for working with Hurl formatted files. We use it to convert an Hurl file to a JSON file:</p>

<pre><code>$ hurlfmt --out json test.hurl | jq
{
  "entries": [
    {
      "request": {
        "method": "GET",
        "url": "http://localhost:8000/test.json"
      },
      "response": {
        "status": 200,
...
</code></pre>

<p>This can be useful if you want to convert your big Hurl tests suite to a solution that uses a different format.</p>

<p>With 3.0.0, we’ve added the ability to convert curl command lines to Hurl.</p>

<p>For instance, using <code>hurlfmt</code>:</p>

<pre><code class="language-shell">$ hurlfmt --in curl curl.txt
</code></pre>

<p>We can convert this chain of curl commands:</p>

<pre><code>curl http://localhost:8000/hello
curl http://localhost:8000/custom-headers -H 'Fruit:Raspberry' -H 'Fruit:Apple' -H 'Fruit:Banana' -H 'Fruit: Grape' -H 'Color:Green'
curl --header 'Content-Type: application/json' --data $'{"name": "Bob","password":"secret","age": 30}' 'http://localhost:8000/post-json'
curl --header 'Content-Type:' --data '@tests_ok/data.bin' 'http://localhost:8000/post-file'
curl --location 'http://localhost:8000/redirect-absolute'
curl -k https://localhost:8001/hello
</code></pre>

<p>to this Hurl file:</p>

<pre><code class="language-hurl">GET http://localhost:8000/hello

GET http://localhost:8000/custom-headers
Fruit: Raspberry
Fruit: Apple
Fruit: Banana
Fruit: Grape
Color: Green

POST http://localhost:8000/post-json
Content-Type: application/json
```
{"name": "Bob","password":"secret","age": 30}
```

POST http://localhost:8000/post-file
Content-Type:
file, tests_ok/data.bin;

GET http://localhost:8000/redirect-absolute
[Options]
location: true

GET https://localhost:8001/hello
[Options]
insecure: true
</code></pre>

<h3 id="from-your-browser-to-hurl">From your browser to Hurl</h3>

<p>Another use case is to convert a request played in your favorite browser to Hurl format and replay it with Hurl. Using
Firefox, in the Developer Tools / Network tab, you can export an HTTP request to a curl command:</p>

<p>
    <img class="u-drop-shadow u-border" src="/assets/img/firefox.png" width="100%" alt="Export request to curl in Firefox" />
</p>

<p>Then using <code>hurlfmt</code>, you will be able to convert this request to Hurl. We’re very happy to have
implemented this feature and we’re looking forward to feedback!</p>

<h2 id="simplify-hurls-rust-apis">Simplify Hurl’s Rust APIs</h2>

<p>Hurl purpose has always been to be an excellent command line application, whether you want to get datas from a website or
you want to add integration tests in A CI/CD pipeline. Some people (to our surprise), are also using <a href="https://crates.io/crates/hurl">Hurl’s crate</a> (a library in the Rust world)
to integrate Hurl in there own program. With 3.0.0, we’ve given some attention to the APIs exposed by Hurl’s crate and, now,
it’s even simpler to run an Hurl content and get result.</p>

<p>A minimal Rust sample using the <code>run</code> method:</p>

<pre><code class="language-rust">// A simple Hurl sample
let content = r#"
GET http://localhost:8000/hello
HTTP 200
"#;

// Define runner options and logger
let options = RunnerOptionsBuilder::new()
    .follow_location(true)
    .verbosity(Some(Verbosity::Verbose))
    .build();
let logger = LoggerBuilder::new().build();

// Set variables
let mut variables = HashMap::default();
variables.insert("name".to_string(), Value::String("toto".to_string()));

// Run the Hurl sample
let result = runner::run(
    content,
    &amp;options,
    &amp;variables,
    &amp;logger
);
</code></pre>

<p>To run a Hurl content, you have to provide the content as a string slice, a logger, some variables and runner options.
Runner options and logger are created <a href="https://rust-unofficial.github.io/patterns/patterns/creational/builder.html">using the Rust builder pattern</a>: this way we can add more options without breaking binary
compatibility (thanks <a href="https://twitter.com/robjtede">@robjtede</a>).</p>

<h2 id="thats-all">That’s All</h2>

<p>There are other improvements and bug fixes, you can check a complete list <a href="https://github.com/Orange-OpenSource/hurl/releases/tag/3.0.0">in our release note</a>.
If you like Hurl, don’t hesitate to <a href="https://github.com/Orange-OpenSource/hurl/stargazers">give us a star on GitHub</a> or share it on <a href="https://twitter.com/HurlDev">Twitter</a>!</p>

<p>We’ll be happy to hear from you, either for enhancement requests or for sharing your success story using Hurl!</p>]]></content>
        <author><name></name></author>
        <summary>Announcing Hurl 3.0.0</summary>
    </entry>
    <entry>
        <title>Hurl 2.0.0, the GraphQL Edition</title>
        <link href="https://hurl.dev/blog/2023/01/25/hurl-2.0.0-the-graphql-edition.html" rel="alternate" type="text/html" title="Hurl 2.0.0, the GraphQL Edition" />
        <published>2023-01-25T00:00:00+02:00</published>
        <updated>2023-01-25T00:00:00+02:00</updated>
        <id>https://hurl.dev/blog/2023/01/25/hurl-2.0.0-the-graphql-edition.html</id>
        <content type="html"><![CDATA[<h1 id="hurl-200-the-graphql-edition">Hurl 2.0.0, the GraphQL Edition</h1>

<div class="blog-post-date">Jan. 25, 2023</div>

<p>
    <img class="u-theme-light u-drop-shadow u-border" src="/assets/img/hurl-plus-graphql-light.png" width="100%" alt="Hurl plus GraphQL equals love" />
</p>

<p>Christmas has been busy for the Hurl team! We’re happy to announce <strong>Hurl 2.0.0</strong>, with a lot of new features
and bug fixes. If you don’t know <a href="https://hurl.dev">Hurl</a>, it’s a command line tool powered by <a href="https://curl.se">curl</a> that runs HTTP requests defined in
a simple text format:</p>

<pre><code class="language-hurl"># Create a new cat:
POST https://example.org/api/cats
{
 "name": "Kitty",
 "color": "black"
}
HTTP 201
[Captures]
cat-id: jsonpath "$.id"


# Get our new cat:
GET https://example.org/api/cats/{{cat-id}}
HTTP 200
[Asserts]
jsonpath "$.lives" == 9
</code></pre>

<p>Hurl can be used to get data like <a href="https://curl.se">curl</a>, or as a <strong>testing tool for JSON/XML apis</strong> and HTML content.</p>

<p>So, <strong>what’s new in 2.0.0</strong>?</p>

<ul>
  <li><a href="#graphql-query-support">GraphQL Query Support</a></li>
  <li><a href="#processing-data-with-filters">Processing Data with Filters</a></li>
  <li><a href="#various-curl-options">Various curl Options</a></li>
  <li><a href="#minor-syntax-changes">Minor Syntax Changes</a></li>
</ul>

<h2 id="graphql-query-support">GraphQL Query Support</h2>

<p>Hurl can now be used to send <a href="https://graphql.org">GraphQL</a> query request very easily. The syntax is natural and use <code>&#96;&#96;&#96;</code> body with a <code>graphql</code> hint.</p>

<p>For instance, using <a href="https://docs.github.com/en/graphql">GitHub GraphQL APIs</a>, we can check the number of stars of a project:</p>

<pre><code class="language-hurl">POST https://api.github.com/graphql
Authorization: bearer {{token}}
```graphql
{
  repository(owner: "Orange-OpenSource", name: "hurl") {
    stargazerCount
  }
}
```
HTTP 200
</code></pre>

<p>And this Hurl file can be run like this:</p>

<pre><code class="language-shell">$ hurl --variable token=FOO github.hurl | jq
{
  "data": {
    "repository": {
      "stargazerCount": 3578
    }
  }
}
</code></pre>

<p>It’s a very <em>“Markdowny”</em> syntax which re-use existing Hurl <a href="/docs/request.html#multiline-string-body">multiline body</a>.</p>

<p>GraphQL queries, of course, can use GraphQL variables:</p>

<pre><code class="language-hurl">POST https://api.starwars.com/graphql
```graphql
query HeroNameAndFriends($episode: Episode) {
  hero(episode: $episode) {
    name
    friends {
      name
    }
  }
}

variables {
  "episode": "JEDI"
}
```
HTTP 200
</code></pre>

<p>And, as any multiline body, GraphQL queries can be templatized with Hurl variables!</p>

<pre><code class="language-hurl">POST https://api.starwars.com/graphql
```graphql
query HeroNameAndFriends($episode: Episode) {
  hero(episode: $episode) {
    name
    friends {
      name
    }
  }
}

variables {
  "episode": {{episode}}
}
```
HTTP 200
</code></pre>

<p>As GraphQL APIs return JSON, we can add asserts on the HTTP response:</p>

<pre><code class="language-hurl">POST https://api.starwars.com/graphql
```graphql
{
  human(id: "1000") {
    name
    height
  }
}
```

HTTP 200
[Asserts]
jsonpath "$.data.human.name" == "Luke Skywalker"
jsonpath "$.data.human.height" == 1.72
</code></pre>

<h2 id="processing-data-with-filters">Processing Data with Filters</h2>

<p>Sometimes you want to process response body before capturing data or adding tests.</p>

<p>Let’s say we have an endpoint that returns an HTTP header <code>x-servers</code> containing a joined list of servers (for instance <code>rec1.org,rec3.org</code>).
You want to test the value of this header: number of server, value of server 1 etc... You can now use <a href="/docs/filters.html">filters</a>
to process the response headers and add clean asserts:</p>

<pre><code class="language-hurl">GET https://example.org/api

HTTP 200
[Asserts]
header "x-servers" split "," count == 2
header "x-servers" split "," nth 0 == "rec1.org"
header "x-servers" split "," nth 1 == "rec3.org"
jsonpath "$.books" count == 12
</code></pre>

<p>In this sample, <code>header "x-servers"</code> extracts the HTTP header from the response. Then, we have a chain of two filters
<code>split "," nth 0</code>. The first filter <code>split</code> turns the header to a list, and the second filter, <code>nth</code>, returns an element of the list.
Then we have our final test with <code>== "rec1.org"</code>.</p>

<div class="schema-container schema-container u-font-size-1 u-font-size-3-md">
 <div class="schema">
    <span class="schema-token schema-color-2">header "x-servers"<span class="schema-label">query</span></span>
    <span class="schema-token schema-color-1">split "," nth 0<span class="schema-label">2 filters</span></span>
    <span class="schema-token schema-color-3">== "rec1.org"<span class="schema-label">predicate</span></span>
 </div>
</div>

<p>Filters can also be applied on captures:</p>

<pre><code class="language-hurl">GET https://example.org/api

HTTP 200
[Captures]
name: jsonpath "$user.id" replace /\d/ "x" # Make our user anonymous
</code></pre>

<p>Let’s take a final example, with a live existing service that
returns a CSV of stock exchanges <a href="https://csvbase.com/meripaterson/stock-exchanges">https://csvbase.com/meripaterson/stock-exchanges</a></p>

<p>First, we split our response body by lines and save it in a variable <code>lines</code>.</p>

<pre><code class="language-hurl">GET https://csvbase.com/meripaterson/stock-exchanges

HTTP 200
[Captures]
rows: body split "\n"
</code></pre>

<p>Then, we create two other variables <code>australia</code> and <code>algeria</code> that are row 7 and 18.</p>

<pre><code class="language-hurl">GET https://csvbase.com/meripaterson/stock-exchanges

HTTP 200
[Captures]
rows: body split "\n"
australia: variable "rows" nth 7 split ","
algeria: variable "rows" nth 18 split ","
</code></pre>

<p>Now that we have our row 7 and 18, we can add assert on specifics columns:</p>

<pre><code class="language-hurl">GET https://csvbase.com/meripaterson/stock-exchanges

HTTP 200
[Captures]
lines: body split "\n"
australia: variable "lines" nth 7 split ","
algeria: variable "lines" nth 18 split ","
[Asserts]
variable "australia" nth 1 == "Australia &amp; Oceania"
variable "australia" nth 2 == "Australia"
variable "algeria" nth 1 == "Africa"
variable "algeria" nth 2 == "Algeria"
</code></pre>

<p>Et voilà 🎉!</p>

<p>Filters can be used to transform the HTTP response data easily. We have included a <a href="/docs/filters.html#description">first round of filters</a> <code>count</code>,
<code>htmlEscape</code>, <code>htmlUnescape</code>, <code>nth</code>, <code>regex</code>, <code>replace</code>, <code>split</code>, <code>toInt</code>, <code>urlDecode</code> and <code>urlEncode</code>. Don’t hesitate to give us some
feedbacks on this nice new feature!</p>

<h2 id="various-curl-options">Various curl Options</h2>

<p>Under the hood, Hurl uses <a href="https://curl.se">curl</a> for HTTP transfers. We have implemented the following curl options: <a href="/docs/manual.html#cert"><code>-E/--cert</code></a>, <a href="/docs/manual.html#connect-to"><code>--connect-to</code></a>,
<a href="/docs/manual.html#key"><code>--key</code></a>, <a href="/docs/manual.html#resolve"><code>--resolve</code></a> and <a href="/docs/manual.html#ssl-no-revoke"><code>--ssl-no-revoke</code></a>. For instance, given this Hurl file <code>hello.hurl</code>:</p>

<pre><code class="language-hurl">GET http://foo.com/hello
HTTP 200
`Hello World!`

GET http://bar.com/hello
HTTP 200
`Hello World!`

GET http://baz.com/hello
HTTP 200
`Hello World!`
</code></pre>

<p>You can force the resolution of <code>foo.com</code>, <code>bar.com</code> and <code>baz.com</code> to <code>localhost</code> with <a href="/docs/manual.html#connect-to"><code>--connect-to</code></a>:</p>

<pre><code class="language-shell">$ hurl --connect-to foo.com:80:localhost:8000 \
       --connect-to bar.com:80:localhost:8000 \
       --connect-to baz.com:80:localhost:8000 \
       hello.hurl
</code></pre>

<h2 id="minor-syntax-changes">Minor Syntax Changes</h2>

<p>Astute readers have already spot some minor syntax changes. Instead of <strong><code>HTTP/*</code></strong> for wildcard HTTP version test, you can simply
write <strong><code>HTTP</code></strong> now (the first syntax still work but is deprecated)</p>

<pre><code class="language-hurl"># New Syntax
GET https://foo.com
HTTP 200

# Deprecated syntax
GET https://foo.com
HTTP/* 200
</code></pre>

<p>If you want to add precise tests on HTTP version, you can still use <code>HTTP/1.0</code>, <code>HTTP/1.1</code> and <code>HTTP/2</code>:</p>

<pre><code class="language-hurl">GET https://foo.com
HTTP/2 200

GET https://bar.com
HTTP/1.1 200

GET https://baz.com
HTTP/1.0 200
</code></pre>

<p>Thanks to <a href="https://github.com/jmoore34">@jmoore34</a> for this idea, it’s obvious now you see it!</p>

<p>Finally, plain text body have been tweaked, to allow the use of a language hint like <code>graphql</code> or <code>json</code>:</p>

<ul>
  <li>
    <p>Post a CSV:</p>

    <pre><code class="language-hurl">POST https://example.com/csv
```
line1,red,1
line2,green,2
line3,green,3
```
</code></pre>
  </li>
  <li>
    <p>Use a GraphQL query</p>

    <pre><code class="language-hurl">POST https://example.com/graphql
```graphql
{
  human {
    name
    }
}
```
</code></pre>
  </li>
  <li>
    <p>Post a JSON body</p>

    <pre><code class="language-hurl">POST https://example.com/json
```json
{
  "name": "toto",
  "age": 18
}
```
</code></pre>
  </li>
  <li>
    <p>Post a JSON body without <code>&#96;&#96;&#96;</code> (this shorter syntax is prefered over the previous one)</p>

    <pre><code class="language-hurl">POST https://example.com/json
{
  "name": "toto",
  "age": 18
}
</code></pre>
  </li>
  <li>
    <p>And finally, post a single string without newline:</p>

    <pre><code class="language-hurl">POST https://example.com/csv
`Hello world!`
</code></pre>
  </li>
</ul>

<p>You may notice that the syntax takes huge inspiration from Markdown and that’s <em>very intentional</em>!</p>

<h2 id="thats-all">That’s All</h2>

<p>There are other improvements and bug fixes, you can check a complete list <a href="https://github.com/Orange-OpenSource/hurl/blob/master/CHANGELOG.md#2.0.0">in our release note</a>.
If you like Hurl, don’t hesitate to <a href="https://github.com/Orange-OpenSource/hurl/stargazers">give us a star on GitHub</a> or share it on <a href="https://twitter.com/HurlDev">Twitter</a>!</p>

<p>We’ll be happy to hear from you, either for enhancement requests or for sharing your success story using Hurl!</p>]]></content><author><name></name></author>
        <summary>Christmas has been busy for the Hurl team! We’re happy to announce Hurl 2.0.0, with a lot of new features and bug fixes.</summary>
    </entry>
    <entry>
        <title>Announcing Hurl 1.8.0</title>
        <link href="https://hurl.dev/blog/2022/11/07/announcing-hurl-1.8.0.html" rel="alternate" type="text/html" title="Announcing Hurl 1.8.0" />
        <published>2022-11-07T00:00:00+02:00</published>
        <updated>2022-11-07T00:00:00+02:00</updated>
        <id>https://hurl.dev/blog/2022/11/07/announcing-hurl-1.8.0.html</id>
        <content type="html"><![CDATA[<h1 id="announcing-hurl-180">Announcing Hurl 1.8.0</h1>

<div class="blog-post-date">Nov. 07, 2022</div>

<p>The Hurl team is happy to announce <a href="https://github.com/Orange-OpenSource/hurl/releases/tag/1.8.0">Hurl 1.8.0</a> 🥳!
.</p>

<p><a href="https://hurl.dev">Hurl</a> is a command line tool powered by <a href="https://curl.se">curl</a>, that runs HTTP requests defined
in a <strong>simple plain text format</strong>:</p>

<pre><code class="language-hurl"># Get home:
GET https://example.org

HTTP/1.1 200
[Captures]
csrf_token: xpath "string(//meta[@name='_csrf_token']/@content)"

# Do login!
POST https://example.org/login?user=toto&amp;password=1234
X-CSRF-TOKEN:

HTTP/1.1 302
</code></pre>

<p>Hurl can be used to get data like <a href="https://curl.se">curl</a>, or as a <strong>testing tool for JSON/XML apis</strong> and HTML content.</p>

<p>So, <strong>what’s new in 1.8.0</strong>?</p>

<ul>
  <li><a href="#polling-and-retry">Polling and Retry</a></li>
  <li><a href="#url-assert">URL Assert</a></li>
  <li><a href="#libcurl-debug-logs">curl Debug Logs</a></li>
</ul>

<h2 id="polling-and-retry">Polling and Retry</h2>

<p>You can now <strong>retry requests</strong> which asserts and captures have failed. This way, you can write
<strong>polling scenarios</strong> or create robust tests even in flaky conditions. To activate retry, you can either use <a href="/docs/manual.html#retry"><code>--retry</code> option</a> (every request of the run can be retried), or you can target a specific request with an <a href="/docs/request.html#options"><code>[Options]</code> section</a>.</p>

<p>Let’s say we have an API to create a ressource. Once created, we want to poll this resource and wait until it reaches
a certain state.</p>

<p>First we create a new resource with a <code>POST</code> request. We capture the id of the resource to be able to use it
in the following requests:</p>

<pre><code class="language-hurl"># Create a new job
POST https://api.example.org/jobs

HTTP/* 201
[Captures]
job_id: jsonpath "$.id"
[Asserts]
jsonpath "$.state" == "RUNNING"
</code></pre>

<p>Then, we pull the resource with a <code>GET</code> request and check its <code>state</code> value. We’ve configured the <code>GET</code> request to
be retried with an <a href="/docs/request.html#options"><code>[Options]</code> section</a>. The <a href="/docs/asserting-response.html#jsonpath-assert">JSONPath assert</a> tests the value of <code>state</code> field. Because
of the retry option, the <code>GET</code> request is going to be retried until <code>state</code>’s value is <code>COMPLETED</code>:</p>

<pre><code class="language-hurl"># ...

# Pull job status until it is completed
GET https://api.example.org/jobs/
[Options]
retry: 10

HTTP/* 200
[Asserts]
jsonpath "$.state" == "COMPLETED"
</code></pre>

<p>So, the full scenario looks like:</p>

<pre><code class="language-hurl"># Create a new job
POST https://api.example.org/jobs

HTTP/* 201
[Captures]
job_id: jsonpath "$.id"
[Asserts]
jsonpath "$.state" == "RUNNING"


# Pull job status until it is completed
GET https://api.example.org/
[Options]
retry: 10

HTTP/* 200
[Asserts]
jsonpath "$.state" == "COMPLETED"
</code></pre>

<p>Retry work on any asserts, whether they’re explicit (with an <a href="/docs/asserting-response.html#asserts"><code>[Asserts]</code> section</a>), or implicit (the <a href="/docs/asserting-response.html#version-status">status code</a>). For instance, the following snippet:</p>

<pre><code class="language-hurl">GET https://api.example.org/123456
[Options]
retry: 10
retry-interval: 4000
HTTP/* 200
</code></pre>

<p>will poll until <code>https://api.example.org/123456</code> returns a <code>200 OK</code>, with a 4 seconds delay between each retry.</p>

<p>Finally, one common need in shell script is to wait until a specific URL is ready and returns a 200 OK. This can be
easily done now with Hurl:</p>

<pre><code class="language-shell">$ echo -e 'GET https://example.org/health\nHTTP/* 200' | hurl --retry
</code></pre>

<h2 id="url-assert">URL Assert</h2>

<p>The <a href="/docs/asserting-response.html#url-assert">URL assert</a> allows check on the final URL of a request: it’s particularly interesting when you tell Hurl to follow
redirects (either with <a href="/docs/manual.html#location"><code>--location</code> option</a> or with an <a href="/docs/request.html#options"><code>Options</code> section</a>):</p>

<pre><code class="language-hurl"># Check that HTTP is redirected to HTTPS:
GET http://example.org
[Options]
location: true

HTTP/* 200
[Asserts]
url == "https://example.org"
</code></pre>

<h2 id="curl-debug-logs">curl Debug Logs</h2>

<p>In Hurl 1.7.0, we introduced <a href="/docs/manual.html#very-verbose"><code>--very-verbose</code> option</a> to output request and response bodies. Now, when <code>very-verbose</code> is used, Hurl displays debug logs from libcurl (prefixed with <code>**</code>), allowing displaying SSL certificates infos for instance:</p>

<pre><code class="language-shell">$ echo 'HEAD https://hurl.dev' | hurl --very-verbose
* Options:
*     fail fast: true
*     follow redirect: false
*     insecure: false
*     max redirect: 50
*     retry: false
*     retry max count: 10
* ------------------------------------------------------------------------------
* Executing entry 1
*
* Cookie store:
*
* Request:
* HEAD https://hurl.dev
*
* Request can be run with the following curl command:
* curl 'https://hurl.dev' --head
*
**   Trying 145.239.78.213:443...
** Connected to hurl.dev (145.239.78.213) port 443 (#0)
** ALPN, offering h2
** ALPN, offering http/1.1
** successfully set certificate verify locations:
**  CAfile: /etc/ssl/cert.pem
**  CApath: none
** (304) (OUT), TLS handshake, Client hello (1):
** (304) (IN), TLS handshake, Server hello (2):
** TLSv1.2 (IN), TLS handshake, Certificate (11):
** TLSv1.2 (IN), TLS handshake, Server key exchange (12):
** TLSv1.2 (IN), TLS handshake, Server finished (14):
** TLSv1.2 (OUT), TLS handshake, Client key exchange (16):
** TLSv1.2 (OUT), TLS change cipher, Change cipher spec (1):
** TLSv1.2 (OUT), TLS handshake, Finished (20):
** TLSv1.2 (IN), TLS change cipher, Change cipher spec (1):
** TLSv1.2 (IN), TLS handshake, Finished (20):
** SSL connection using TLSv1.2 / ECDHE-RSA-CHACHA20-POLY1305
** ALPN, server accepted to use h2
** Server certificate:
**  subject: CN=hurl.dev
**  start date: Sep 30 22:15:32 2022 GMT
**  expire date: Dec 29 22:15:31 2022 GMT
**  subjectAltName: host "hurl.dev" matched cert's "hurl.dev"
**  issuer: C=US; O=Let's Encrypt; CN=R3
**  SSL certificate verify ok.
** Using HTTP2, server supports multiplexing
** Connection state changed (HTTP/2 confirmed)
** Copying HTTP/2 data in stream buffer to connection buffer after upgrade: len=0
** Using Stream ID: 1 (easy handle 0x14c811800)
&gt; HEAD / HTTP/2
&gt; Host: hurl.dev
&gt; accept: */*
&gt; user-agent: hurl/1.8.0-SNAPSHOT
&gt;
* Request body:
*
** Connection state changed (MAX_CONCURRENT_STREAMS == 128)!
** Connection #0 to host hurl.dev left intact
* Response: (received 0 bytes in 110 ms)
*
&lt; HTTP/2 200
&lt; server: nginx/1.14.2
&lt; date: Mon, 31 Oct 2022 13:12:41 GMT
&lt; content-type: text/html
&lt; content-length: 28370
&lt; last-modified: Thu, 27 Oct 2022 14:15:30 GMT
&lt; etag: "635a9282-6ed2"
&lt; accept-ranges: bytes
&lt;
* Response body:
*
*
</code></pre>

<h2 id="thats-all">That’s All</h2>

<p>If you like Hurl, don’t hesitate to <a href="https://github.com/Orange-OpenSource/hurl/stargazers">give us a star on GitHub</a> or share it on <a href="https://twitter.com/HurlDev">Twitter</a>!</p>

<p>We’ll be happy to hear from you, either for enhancement requests or for sharing your success story using Hurl!</p>]]></content><author><name></name></author>
        <summary>The Hurl team is happy to announce Hurl 1.8.0.</summary>
    </entry>
    <entry>
        <title>Announcing Hurl 1.7.0</title>
        <link href="https://hurl.dev/blog/2022/09/15/announcing-hurl-1.7.0.html" rel="alternate" type="text/html" title="Announcing Hurl 1.7.0" />
        <published>2022-09-15T00:00:00+02:00</published>
        <updated>2022-09-15T00:00:00+02:00</updated>
        <id>https://hurl.dev/blog/2022/09/15/announcing-hurl-1.7.0.html</id>
        <content type="html"><![CDATA[<h1 id="announcing-hurl-170">Announcing Hurl 1.7.0</h1>

<div class="blog-post-date">Sep. 15, 2022</div>

<p>The Hurl team is happy to announce <a href="https://github.com/Orange-OpenSource/hurl/releases/tag/1.7.0">a new version of Hurl, 1.7.0</a>.</p>

<p><a href="https://hurl.dev">Hurl</a> is a command line tool powered by <a href="https://curl.se">curl</a>, that runs HTTP requests defined
in a simple plain text format:</p>

<pre><code class="language-hurl"># Get home:
GET https://example.org

HTTP/1.1 200
[Captures]
csrf_token: xpath "string(//meta[@name='_csrf_token']/@content)"

# Do login!
POST https://example.org/login?user=toto&amp;password=1234
X-CSRF-TOKEN:

HTTP/1.1 302
</code></pre>

<p>Hurl can be used to get data like curl, or as an integration testing tool for JSON/XML HTTP apis / HTML content.</p>

<p>So, <strong>what’s new in 1.7.0</strong>?</p>

<ul>
  <li><a href="#verbose-output-improvement">Verbose output improvement</a></li>
  <li><a href="#use-level-request-options">Use level request options</a></li>
  <li><a href="#using-hurl-in-nodejs">Using Hurl in Node.js</a></li>
  <li><a href="#support-for-xml-namespace-in-xpath">Support for XML namespace in XPath</a></li>
  <li><a href="#others">Others...</a></li>
</ul>

<h2 id="verbose-output-improvement">Verbose Output Improvement</h2>

<p>We’ve improved <a href="/docs/manual.html#verbose"><code>-v/--verbose</code> option</a>:</p>

<ul>
  <li>add more color!</li>
  <li>add <a href="/docs/manual.html#very-verbose"><code>--very-verbose</code> option</a> to output request and response body for each entry of your Hurl file</li>
</ul>

<p>First, we’ve added more color to the debug output.</p>

<p>In 1.6.1, a verbose output of Hurl looks like:</p>

<pre><code class="language-shell">$ echo 'GET https://google.fr' | hurl --verbose
* fail fast: true
* insecure: false
* follow redirect: false
* max redirect: 50
* ------------------------------------------------------------------------------
* executing entry 1
*
* Cookie store:
*
* Request
* GET https://google.fr
*
* request can be run with the following curl command:
* curl 'https://google.fr'
*
&gt; GET / HTTP/2
&gt; Host: google.fr
&gt; accept: */*
&gt; user-agent: hurl/1.6.1
&gt;
&lt; HTTP/2 301
&lt; location: https://www.google.fr/
&lt; content-type: text/html; charset=UTF-8
&lt; date: Thu, 18 Aug 2022 09:55:23 GMT
&lt; expires: Thu, 18 Aug 2022 09:55:23 GMT
&lt; cache-control: private, max-age=2592000
&lt; server: gws
&lt; content-length: 219
&lt; x-xss-protection: 0
&lt; x-frame-options: SAMEORIGIN
&lt; set-cookie: CONSENT=PENDING+677; expires=Sat, 17-Aug-2024 09:55:23 GMT; path=/; domain=.google.fr; Secure
&lt; p3p: CP="This is not a P3P policy! See g.co/p3phelp for more info."
&lt; alt-svc: h3=":443"; ma=2592000,h3-29=":443"; ma=2592000,h3-Q050=":443"; ma=2592000,h3-Q046=":443"; ma=2592000,h3-Q043=":443"; ma=2592000,quic=":443"; ma=2592000; v="46,43"
&lt;
*
&lt;HTML&gt;&lt;HEAD&gt;&lt;meta http-equiv="content-type" content="text/html;charset=utf-8"&gt;
&lt;TITLE&gt;301 Moved&lt;/TITLE&gt;&lt;/HEAD&gt;&lt;BODY&gt;
&lt;H1&gt;301 Moved&lt;/H1&gt;
The document has moved
&lt;A HREF="https://www.google.fr/"&gt;here&lt;/A&gt;.
&lt;/BODY&gt;&lt;/HTML&gt;
</code></pre>

<p>In 1.7.0, headers are highlighted and requests and responses are more visible:</p>

<pre><code class="language-shell">$ echo 'GET https://google.fr' | hurl --verbose
* Options:
*     fail fast: true
*     insecure: false
*     follow redirect: false
*     max redirect: 50
* ------------------------------------------------------------------------------
* Executing entry 1
*
* Cookie store:
*
* Request:
* GET https://google.fr
*
* Request can be run with the following curl command:
* curl 'https://google.fr'
*
&gt; GET / HTTP/2
&gt; Host: google.fr
&gt; accept: */*
&gt; user-agent: hurl/1.7.0-snapshot
&gt;
* Response: (received 219 bytes in 111 ms)
*
&lt; HTTP/2 301
&lt; location: https://www.google.fr/
&lt; content-type: text/html; charset=UTF-8
&lt; date: Thu, 18 Aug 2022 09:56:40 GMT
&lt; expires: Thu, 18 Aug 2022 09:56:40 GMT
&lt; cache-control: private, max-age=2592000
&lt; server: gws
&lt; content-length: 219
&lt; x-xss-protection: 0
&lt; x-frame-options: SAMEORIGIN
&lt; set-cookie: CONSENT=PENDING+308; expires=Sat, 17-Aug-2024 09:56:40 GMT; path=/; domain=.google.fr; Secure
&lt; p3p: CP="This is not a P3P policy! See g.co/p3phelp for more info."
&lt; alt-svc: h3=":443"; ma=2592000,h3-29=":443"; ma=2592000,h3-Q050=":443"; ma=2592000,h3-Q046=":443"; ma=2592000,h3-Q043=":443"; ma=2592000,quic=":443"; ma=2592000; v="46,43"
&lt;
*
&lt;HTML&gt;&lt;HEAD&gt;&lt;meta http-equiv="content-type" content="text/html;charset=utf-8"&gt;
&lt;TITLE&gt;301 Moved&lt;/TITLE&gt;&lt;/HEAD&gt;&lt;BODY&gt;
&lt;H1&gt;301 Moved&lt;/H1&gt;
The document has moved
&lt;A HREF="https://www.google.fr/"&gt;here&lt;/A&gt;.
&lt;/BODY&gt;&lt;/HTML&gt;
</code></pre>

<p>Error on asserts are also colored now:</p>

<pre><code class="language-shell">error: Assert status code
  --&gt; /tmp/test.hurl:2:8
   |
 2 | HTTP/* 200
   |        ^^^ actual value is &lt;301&gt;
   |
</code></pre>

<p>Colors can be forced with <a href="/docs/manual.html#color"><code>--color</code></a>, or deactivated with <a href="/docs/manual.html#no-color"><code>--no-color</code></a>, and Hurl supports now <code>NO_COLOR</code> environnement
variables (see <a href="http://no-color.org">http://no-color.org</a>).</p>

<p>Secondly, intermediary request and response bodies can be outputted in debug with <a href="/docs/manual.html#very-verbose"><code>--very-verbose</code> option</a>. By default,
the last HTTP body response is outputted on standard output (like <a href="https://curl.se">curl</a>). With <a href="/docs/manual.html#verbose"><code>--verbose</code> option</a>, request and response
headers are also displayed on standard error, and with <a href="/docs/manual.html#very-verbose"><code>--very-verbose</code> option</a>, request and response bodies are finally also
displayed on standard error. If your Hurl file has a lot of entries, debug logs can be pretty large, but you can mitigate it
with the brand new <code>[Options]</code> section that we’re going to present now.</p>

<h2 id="use-level-request-options">Use Level Request Options</h2>

<p>Options such as <a href="/docs/manual.html#location"><code>--location</code></a>, <a href="/docs/manual.html#verbose"><code>--verbose</code></a>, <a href="/docs/manual.html#insecure"><code>--insecure</code></a> can be used at the command line and applied to every
request of an Hurl file. An <code>[Options]</code> section can be used to apply option to only one request (without passing options
to the command line), while other requests are unaffected.</p>

<pre><code class="language-hurl">GET https://example.org
# An options section, each option is optional and applied only to this request...
[Options]
cacert: /etc/cert.pem   # a custom certificate file
compressed: true        # request a compressed response
insecure: true          # allows insecure SSL connections and transfers
location: true          # follow redirection for this request
max-redirs: 10          # maximum number of redirections
verbose: true           # allow verbose output
very-verbose: true      # allow more verbose output
</code></pre>

<p>So, given this Hurl file</p>

<pre><code class="language-hurl">GET https://google.fr
HTTP/* 301

GET https://google.fr
[Options]
location: true
HTTP/* 200

GET https://google.fr
HTTP/* 301
</code></pre>

<p>The second entry will follow location (and so we can test the status code to be 200 instead of 301).</p>

<p>You can use it to logs a specific entry:</p>

<pre><code class="language-hurl"># ... previous entries

GET https://api.example.org
[Options]
very-verbose: true

HTTP/* 200

# ... next entries
</code></pre>

<p>And only the debug logs of the specific entry will be displayed on standard error.</p>

<h2 id="using-hurl-in-nodejs">Using Hurl in Node.js</h2>

<p>Started since 1.6.1, Hurl is <a href="https://www.npmjs.com/package/@orangeopensource/hurl">available on npm</a>, and can be easily integrated in various JavaScript projects.
Hurl on npm is a thin JavaScript wrapper around the native binary.</p>

<p>To install it, just run:</p>

<pre><code class="language-shell">$ npm install --save-dev @orangeopensource/hurl
</code></pre>

<p>And then edit your <code>package.json</code>:</p>

<pre><code class="language-json">{
  "name": "sample-app",
  "scripts": {
    "test": "hurl --test --glob test/*.hurl",
    ...
  },
  ...
</code></pre>

<p>Now you can run your integration tests with Hurl:</p>

<pre><code class="language-shell">$ npm test
test/bar.hurl: Running [1/3]
test/bar.hurl: Success (5 request(s) in 136 ms)
test/baz.hurl: Running [2/3]
error: Assert failure
  --&gt; test/baz.hurl:6:0
   |
 6 | xpath "string(//title)" == "Something"
   |   actual:   string &lt;301 Moved&gt;
   |   expected: string &lt;Something&gt;
   |

test/baz.hurl: Failure (4 request(s) in 62 ms)
test/foo.hurl: Running [3/3]
test/foo.hurl: Success (10 request(s) in 527 ms)
--------------------------------------------------------------------------------
Executed files:  3
Succeeded files: 2 (66.7%)
Failed files:    1 (33.3%)
Duration:        766 ms
</code></pre>

<h2 id="support-for-xml-namespace-in-xpath">Support for XML namespace in XPath</h2>

<p>JSON and XML are first class citizens in Hurl with <a href="/docs/asserting-response.html#jsonpath-assert">JSONPath assert</a> and <a href="/docs/asserting-response.html#xpath-assert">XPath assert</a>.
For XPath, we now support asserts with namespaces:</p>

<pre><code class="language-xml">&lt;?xml version="1.0"?&gt;
&lt;!-- both namespace prefixes are available throughout --&gt;
&lt;bk:book xmlns:bk='urn:loc.gov:books'
         xmlns:isbn='urn:ISBN:0-395-36341-6'&gt;
    &lt;bk:title&gt;Cheaper by the Dozen&lt;/bk:title&gt;
    &lt;isbn:number&gt;1568491379&lt;/isbn:number&gt;
&lt;/bk:book&gt;
</code></pre>

<p>Can be tested with the following Hurl file:</p>

<pre><code class="language-hurl">GET http://localhost:8000/assert-xpath

HTTP/1.0 200
[Asserts]

xpath "string(//bk:book/bk:title)" == "Cheaper by the Dozen"
xpath "string(//*[name()='bk:book']/*[name()='bk:title'])" == "Cheaper by the Dozen"
xpath "string(//*[local-name()='book']/*[local-name()='title'])" == "Cheaper by the Dozen"

xpath "string(//bk:book/isbn:number)" == "1568491379"
xpath "string(//*[name()='bk:book']/*[name()='isbn:number'])" == "1568491379"
xpath "string(//*[local-name()='book']/*[local-name()='number'])" == "1568491379"
</code></pre>

<p>For convenience, the first default namespace can be used with <code>_</code>.</p>

<p>This sample:</p>

<pre><code class="language-xml">&lt;?xml version="1.0"?&gt;
&lt;!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.0//EN"
              "http://www.w3.org/TR/2001/REC-SVG-20010904/DTD/svg10.dtd"&gt;
&lt;svg xmlns="http://www.w3.org/2000/svg"&gt;
  &lt;style type="text/css"&gt;
    circle:hover {fill-opacity:0.9;}
  &lt;/style&gt;
  &lt;g style="fill-opacity:0.7;"&gt;
    &lt;circle cx="6.5cm" cy="2cm" r="100" style="fill:red; stroke:black; stroke-width:0.1cm" transform="translate(0,50)" /&gt;
    &lt;circle cx="6.5cm" cy="2cm" r="100" style="fill:blue; stroke:black; stroke-width:0.1cm" transform="translate(70,150)" /&gt;
    &lt;circle cx="6.5cm" cy="2cm" r="100" style="fill:green; stroke:black; stroke-width:0.1cm" transform="translate(-70,150)"/&gt;
  &lt;/g&gt;
&lt;/svg&gt;
</code></pre>

<p>Can be tested with the following Hurl file:</p>

<pre><code class="language-hurl">GET http://localhost:8000/assert-xpath-svg

HTTP/1.0 200
[Asserts]
xpath "//_:svg/_:g/_:circle" count == 3
xpath "//*[local-name()='svg']/*[local-name()='g']/*[local-name()='circle']" count ==  3
xpath "//*[name()='svg']/*[name()='g']/*[name()='circle']" count == 3
</code></pre>

<h2 id="others">Others...</h2>

<p>Under the hood, we’ve improved our code and Hurl should be quicker than ever. We’ve completely
rewritten <a href="/docs/grammar.html">our grammar</a> to be more correct and support Hurl future evolutions.</p>

<p>There are other changes and bug fixes in the Hurl 1.7.0 release: check out <a href="https://github.com/Orange-OpenSource/hurl/releases/tag/1.7.0">the release note!</a></p>

<p>And, finally, a big thanks to all our contributors!</p>]]></content>
        <author><name></name></author>
        <summary>The Hurl team is happy to announce a new version of Hurl, 1.7.0.</summary>
    </entry>
    <entry>
        <title>Announcing Hurl 1.6.0</title>
        <link href="https://hurl.dev/blog/2022/02/11/announcing-hurl-1.6.0.html" rel="alternate" type="text/html" title="Announcing Hurl 1.6.0" />
        <published>2022-02-11T00:00:00+02:00</published>
        <updated>2022-02-11T00:00:00+02:00</updated>
        <id>https://hurl.dev/blog/2022/02/11/announcing-hurl-1.6.0.html</id>
        <content type="html"><![CDATA[<h1 id="announcing-hurl-160">Announcing Hurl 1.6.0</h1>

<div class="blog-post-date">Feb. 11, 2022</div>

<p>The Hurl team is happy to announce <a href="https://github.com/Orange-OpenSource/hurl/releases/tag/1.6.0">a new version of Hurl, 1.6.0</a>.</p>

<p><a href="https://hurl.dev">Hurl</a> is a command line tool powered by <a href="https://curl.se">curl</a>, that runs HTTP requests defined
in a simple plain text format:</p>

<pre><code class="language-hurl"># Get home:
GET https://example.org

HTTP/1.1 200
[Captures]
csrf_token: xpath "string(//meta[@name='_csrf_token']/@content)"

# Do login!
POST https://example.org/login?user=toto&amp;password=1234
X-CSRF-TOKEN:

HTTP/1.1 302
</code></pre>

<p>So, <strong>what’s new in 1.6.0</strong>?</p>

<h2 id="simplify-basic-authentication">Simplify basic authentication</h2>

<p>Before 1.6.0, basic authentication could be achieved by computing and sending
an <a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Authorization">Authorization</a> header:</p>

<pre><code class="language-hurl"># Authorization header value can be computed with:
# `echo -n 'bob:secret' | base64`
GET https://example.org/protected
Authorization: Basic Ym9iOnNlY3JldA==
</code></pre>

<p>In 1.6.0, we’ve introduced a basic authentication section to pass username/password
explicitly, without base64 encoding:</p>

<pre><code class="language-hurl">GET https://example.org/protected
[BasicAuth]
bob: secret
</code></pre>

<p>Basic authentication allows per request authentication. If you want to add
basic authentication to all the request of a Hurl file you could use <a href="/docs/manual.html#user"><code>-u/--user</code> option</a>.</p>

<h2 id="regex-literal">Regex literal</h2>

<p><code>matches</code> predicates values are regex. Before 1.6.0, metacharacters in pattern
values should be escaped (like <code>\d</code> etc...):</p>

<pre><code class="language-hurl">GET https://sample.org/hello

HTTP/1.0 200
[Asserts]
jsonpath "$.date" matches "^\\d{4}-\\d{2}-\\d{2}$"
jsonpath "$.name" matches "Hello [a-zA-Z]+!"
</code></pre>

<p>In 1.6.0, we’ve added regex literal for <code>matches</code>:</p>

<pre><code class="language-hurl">GET https://sample.org/hello

HTTP/1.0 200
[Asserts]
jsonpath "$.date" matches /^\d{4}-\d{2}-\d{2}$/
jsonpath "$.name" matches /Hello [a-zA-Z]+!/
</code></pre>

<p>The new asserts are much more readable and easier to write.</p>

<p>Basic authentication section and regex literal has been suggested to us
by <a href="https://github.com/humphd">David Humphrey</a> so thanks again David for your ideas!</p>

<h2 id="interactive-mode-improvements">Interactive mode improvements</h2>

<p>In <a href="/docs/manual.html#interactive">interactive mode</a>, Hurl plays each request and pauses between each entry,
allowing to <a href="/docs/tutorial/debug-tips.html#interactive-mode">debug a session step by step</a>. We’ve improved the interactive
mode to display the next request to be played:</p>

<pre><code>...
&lt; Last-Modified: Fri, 11 Feb 2022 13:28:20 GMT
&lt; Connection: keep-alive
&lt; ETag: "62066474-6f02"
&lt; Accept-Ranges: bytes
&lt;
*

interactive mode

next request:

GET https://hurl.dev/docs/manual.html

Press Q (Quit) or C (Continue)
</code></pre>

<h2 id="other-changes">Other changes</h2>

<p>Under the hood, we’ve improved our code and Hurl should be quicker than ever.
There are other changes and bug fixes in the Hurl 1.6.0 release: check out <a href="https://github.com/Orange-OpenSource/hurl/releases/tag/1.6.0">the release note!</a></p>

<p>If you like Hurl, don’t hesitate <a href="https://github.com/Orange-OpenSource/hurl/stargazers">to give us a star</a>!</p>

<p>And, finally, a big thanks to all our contributors!</p>]]></content>
        <author><name></name></author>
        <summary>The Hurl team is happy to announce a new version of Hurl, 1.6.0.</summary>
    </entry>
    <entry>
        <title>Announcing Hurl 1.5.0</title>
        <link href="https://hurl.dev/blog/2021/12/09/announcing-hurl-1.5.0.html" rel="alternate" type="text/html" title="Announcing Hurl 1.5.0" />
        <published>2021-12-09T00:00:00+02:00</published>
        <updated>2021-12-09T00:00:00+02:00</updated>
        <id>https://hurl.dev/blog/2021/12/09/announcing-hurl-1.5.0.html</id>
        <content type="html"><![CDATA[<h1 id="announcing-hurl-150">Announcing Hurl 1.5.0</h1>

<div class="blog-post-date">Dec. 09, 2021</div>

<p>The Hurl team is happy to announce <a href="https://github.com/Orange-OpenSource/hurl/releases/tag/1.5.0">a new version of Hurl, 1.5.0</a>.
Hurl is a command line tool that runs HTTP requests defined in a simple plain text format.</p>

<p>So, <strong>what’s new in 1.5.0</strong>?</p>

<h2 id="which-curl-is-used-by-hurl">Which curl is used by Hurl?</h2>

<p>Hurl relies upon curl for the HTTP engine. We’ve improved the version output
<a href="/docs/manual.html#version"><code>--version/-h</code></a> to provide informations about which libcurl Hurl is linked with:</p>

<pre><code class="language-shell">$ hurl --version
hurl 1.5.0 libcurl/7.54.0 LibreSSL/2.6.5 zlib/1.2.11
</code></pre>

<h2 id="tests-can-be-launched-with-glob-pattern">Tests can be launched with glob pattern</h2>

<p>Now tests can be launched with <a href="/docs/manual.html#glob"><code>--glob</code> option</a>. This is particularly useful on
Windows where it is less easy to <code>grep</code> and <code>find</code> your test:</p>

<pre><code class="language-shell">$ hurl --glob "tests/**/*.hurl"
</code></pre>

<p>This command will run <code>tests/project1/test1.hurl</code>, <code>tests/project1/test2.hurl</code> and
<code>tests/project2/test3.hurl</code>. Note that to avoid your shell accidentally expanding glob patterns
before Hurl handles them, you should use single quotes or double quotes around each pattern.</p>

<h2 id="using-environment-variables-in-hurl-files">Using Environment Variables in Hurl files</h2>

<p>Before 1.5.0, to inject variables in a Hurl file you can</p>

<ul>
  <li>
    <p>use command line option, with <a href="/docs/manual.html#variable"><code>--variable</code></a>:</p>

    <pre><code class="language-shell">$ hurl --variable host=example.org --variable user=jc test.hurl
</code></pre>
  </li>
  <li>
    <p>use an input file, with <a href="/docs/manual.html#variables-file"><code>--variables-file</code></a>:</p>

    <p>Given <code>file.env</code> defining each variable on a new line:</p>

    <pre><code>host=example.org
user=jc
</code></pre>

    <p>Variables are injected with <code>file.env</code>:</p>

    <pre><code class="language-shell">$ hurl --variables-files file.env test.hurl
</code></pre>
  </li>
</ul>

<p>Starting in 1.5.0, environment variables can be used to inject variables:</p>

<pre><code class="language-shell">$ echo HURL_host=example.org
$ echo HURL_user=jc
$ hurl test.hurl
</code></pre>

<p>Each <code>HURL_foo</code> environment variables will resolve as a <code>foo</code> variable inside
the Hurl file.</p>

<h2 id="junit-and-html-report">JUnit and HTML report</h2>

<p>Test report can be exported in JUnit format:</p>

<pre><code class="language-shell">$ hurl --test --report-junit /tmp/result.xml *.hurl
</code></pre>

<p>To be consistent, we’ve also rename <code>--html</code> options to <code>--report-html</code>. Of course,
one can combine the two kind of reports:</p>

<pre><code class="language-shell">$ hurl --test --report-junit /tmp/result.xml --report-html /tmp/report/ *.hurl
</code></pre>

<h2 id="other-changes">Other changes</h2>

<p>There are other changes and bug fixes in the Hurl 1.5.0 release: check out <a href="https://github.com/Orange-OpenSource/hurl/releases/tag/1.5.0">the release note!</a></p>

<p>And, finally, a big thanks to our contributors!</p>]]></content>
        <author><name></name></author>
        <summary>The Hurl team is happy to announce a new version of Hurl, 1.5.0.</summary>
    </entry>
</feed>